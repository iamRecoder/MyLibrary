CH03. 연산자
======
## 연산자
연산자는 '연산을 수행하는 기호'이다.  
연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.  

### 연산자 종류
- 산술 연산자 : 사칙 연산(+,-,*,/)과 나머지(%) 연산
- 비교 연산자 : 크고 작음과 같고 다름을 비교
- 논리 연산자 : 그리고(AND)와 또는(OR)으로 조건을 연결
- 대입 연산자 : 우변의 값을 좌변에 저장
- 기타 : 형변환 연산자, 삼항 연산자, instanceof 연산자
```text
산술 연산자 : + , - , * , / % , << , >>   
비교 연산자 : > , < , >= , <= , == , !=
논리 연산자 : && , || , ! , & , | , ^ , ~
대입 연산자 : =
기타 : (type) , ?: , instanceof
```

### 연산자의 우선순위와 결합규칙
주의해야 할 연산자 우선순위의 예와 설명
```text
x << 2 + 1
쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다. 그래서 'x << (2+1)'과 같다.

data & 0xFF == 0
비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮으므로 비교연산 후에 비트연산이 수행된다. 그래서 왼쪽의 식은 'data & (0xFF == 0)'과 같다.

x < -1 || x > 3 && x < 5
논리 연산자 중에서 AND를 의미하는 '&'와 '&&'가 OR를 의미하는 '|'와 '||'보다 우선순위가 높다. 
이처럼 수식에 AND와 OR가 함께 사용되는 경우는 다음과 같이 괄호를 사용해서 우선순위를 명확히 하는 것이 좋다. x < -1 || (x>>3 && x<5)
```

연산자의 우선순위에 대해 정리하면 다음과 같다.  
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산자의 진행 방향은 왼쪽에서 오른쪽이다.

### 산술 변환  
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.  
연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 `산술 변환` 또는 `일반 산술 변환`이라 하며, 이 변환은 아항 연산에서만 아니라 단항 연산에서도 일어난다. 
모든 연산에서 `산술 변환`이 일어나지만, 쉬프트 연산자(<<,>>), 증감 연산자(++,--)는 예외이다.  

`산술 변환`의 규칙은 다음과 같다.  
1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)  
   : 피연산자의 값손실을 최소화하기 위해서이다.
   
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.  
   : 정수형의 기본 타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.  

크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환되지만, 반대로 큰 자료형의 값을 작은 자료형의 변수에 저장하려면 명시적으로 형변환 연산자를 사용해서 변환해주어야 한다.  
```ex) byte c = a + b; // 컴파일 에러 발생. 명시적으로 형변환 필요. byte c = (byte)(a + b)```

