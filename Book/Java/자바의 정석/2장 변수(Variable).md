CH02. 변수
========
## 변수
프로그래밍 언어에서의 변수란 값을 저장할 수 있는 메모리상의 공간을 의미한다.  
하나의 변수에 단 하나의 값만 저장할 수 있으므로, 새로운 값을 저장하면 기존의 값은 사라진다.  

### 변수 선언
변수를 선언하면 메모리의 빈 공간에 '변수타입'에 알맞은 크기의 저장공간이 확보되고, 앞으로 이 저장공간은 '변수이름'을 통해 사용할 수 있게 된다.  

### 변수 초기화  
반드시 변수를 '초기화'해야 한다. 메모리는 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 알 수 없는 값(쓰레기 값)이 남아 있을 수 있기 때문이다.  
변수는 한 줄에 하나씩 선언하는 것이 보통이지만,타입이 같은 경우 콤마 ','를 구분자로 여러 변수를 한 줄에 선언하기도 한다.  
변수의 종류에 따라 변수의 초기화를 생략할 수 있는 경우도 있지만, 변수는 사용되기 전에 적절한 값으로 초기화하는 것이 좋다.  

### 변수의 명명 규칙
'변수의 이름'처럼 프로그래밍에서 사용하는 모든 이름을 '식별자'라고 하며, 식별자는 같은 영역 내에서 서로 구분(식별)될 수 있어야한다. 
```text
변수의 명명 규칙
1. 대소문자가 구분되며 길이에 제한이 없다.  
2. 예약어를 사용해서는 안 된다.
3. 숫자로 시작해서는 안 된다.
4. 특수문자는 '_'와 '$'만을 허용한다.
```

그 외에 필수적인 것은 아니지만 자바 프로그래머들에게 권장하는 규칙들은 다음과 같다.  
```text
1. 클래스 이름의 첫 글자는 항상 대문자로 한다. 변수와 메서드 이름의 첫 글자는 항상 소문자로 한다.
2. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
3. 상수의 이름은 모두 대분자로 한다. 여러 단어로 이루어진 경우 '_'로 구분한다.
```
변수의 이름은 짧을수록 좋지만, 약간 길더라도 용도로를 알기 쉽게 '의미있는 이름'으로 하는 것이 바람직하다.  
<br>

## 변수의 타입
값(data)의 종류(type)에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형(data type)이다.  
변수를 선언할 때는 저장하려는 값의 특성을 고려하여 가장 알맞은 자료형을 변수의 타입으로 선택하면 된다.  

### 기본형과 참조형  
`기본형 변수`는 실제 값(data)를 저장하는 반면, `참조형 변수`는 어떤 값이 저장되어 있는 주소(memory address)를 값으로 갖는다.  
자바는 C 언어와 달리 참조형 변수 간의 연산을 할 수 없으므로 실제 연산에 사용되는 것은 모두 기본형 변수이다.  
```text
기본형(primitive type)
- 논리형(boolean), 문자형(char), 정수형(byte,short,int,long), 실수형(float,double)이 있다. 
계산을 위한 실제 값을 저장한다. 모두 8개.

참조형(reference type)
- 객체의 주소를 저장한다. 8개의 기본형을 제외한 나머지 타입.
```

참조형 변수를 선언할 때는 변수의 타입으로 클래스의 이름을 사용하므로 클래스의 이름이 참조변수의 타입이 된다. 그래서 새로운 클래스를 작성한다는 것은 새로운 참조형을 추가하는 셈이다.  
객체를 생성하는 연산자 new의 결과는 생성된 객체의 주소이다. 이 주소가 대입 연산자 '='에 의해서 참조변수에 저장되는 것이다.  

### 기본형
|분류|       타입        | 설명                                                                                            |
|:---:|:---------------:|:----------------------------------------------------------------------------------------------|
|논리형| boolean(1 byte) | true와 false 중 하나의 값으로 갖으며, 조건식과 논리적 계산에 사용된다. boolean은 다른 기본형과의 연산이 불가능하다.                    |
|문자형|  char(2 byte)   | 문자를 저장하는데 사용되며, 변수에 하나의 문자만 저장할 수 있다. 문자형인 char는 문자를 내부적으로 정수(유니코드)로 저장하기 때문에 정수형과 별반 다르지 않다. |
|정수형|  byte(1 byte)   | 이진 데이터를 다룰 때 사용된다.                                                                            |
|정수형|  short(2 byte)  | C 언어와의 호환을 위해 추가되었다.                                                                          |
|정수형|   int(4 byte)   | int는 CPU가 가장 효율적으로 처리할 수 있는 정수 타입이다. 효율적인 실행보다 메모리를 절약하려면 byte나 short를 사용한다.                  |
|정수형|  long(8 byte)   | 길어서 long                                                                                      |
|실수형|float(4 byte)| 실수값을 부동소수점(floating point)방식으로 저장한다. 정밀도는 7 자리이다.                                             |
|실수형|double(8 byte)| float보다 두 배의 크기를 갖기 때문에 double. 정밀도는 15자리이다.                                                  |

int 타입의 변수는 대략 10자리 수의 값을 저장할 수 있으므로 필요에 따라 넉넉하게 Long 타입으로 변수를 선언하는 것이 좋다.  
실수형은 정수형과 저장형식이 달라서 같은 크기라도 훨씬 큰 값을 표현할 수 있으나 오차가 발생할 수 있다는 단점이 있다.  
그래서 정밀도가 중요한데, 정밀도가 높을 수록 발생할 수 있는 오차의 범위가 줄어든다.  

### 상수와 리터럴
- 상수
  - 값을 한 번 저장하면 변경할 수 없는 저장공간
  - 상수를 선언하는 방은 변수의 타입 앞에 키워드 `final`을 붙여주면 된다. 
  - 상수는 반드시 선언과 동시에 초기화해야 하며, 그 후 부터는 상수의 값을 변경하는 것이 허용되지 않는다.
  - 상수의 이름은 모두 대문자로 하는 것이 암묵적인 관례이며, 여러 단어로 이루어져 있는 경우 '_'로 구분한다.  

- 리터럴
  - 그 자체로 값을 의미하는 것

### 리터럴의 타입과 접미사  
정수형과 실수형에는 여러 타입이 존재하므로, 리터럴에 점미사를 붙여서 타입을 구분한다.  
- 정수의 경우, long 타입의 리터럴로 접미사 'l' 또는 'L'을 붙이고 접미사가 없으면 int 타입의 리터럴이다.
- 10진수 외에도 2,8,16 진수로 표현된 리터럴을 변수에 저장할 수 있다. 2진수는 접두사 '0b', 8진수는 접두사 '0', 16진수는 접두사 '0x'를 리터럴 앞에 붙인다.
- JDK 1.7부터 정수형 리터럴의 중간에 구분자 '_'를 넣을 수 있게 되어서 큰 숫자를 편하게 읽을 수 있다.
- 실수형에서는 float 타입의 리터럴에 접미사 'f' 또는 'F'를 붙이고, double 타입의 리터럴에는 접미사 'd' 또는 'D'를 붙인다. 이때, 실수형에서는 double이 기본 자료형이라서 접미사 'd'는 생략이 가능하다.
- 리터럴에 소수점이나 10의 제곱을 나타내는 기호 E 또는 e, 그리고 접미사 f,F,d,D를 포함하고 있으면 실수형 리터럴로 간주된다.
- 리터럴의 접두사와 접미사는 대소문자를 구별하지 않으므로, 대문자와 소문자 중에서 어떤 것을 사용해도 상관없다.

### 타입의 불일치
리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.  
그러나 리터럴의 값이 변수의 타입 범위를 넘어서거나, 리터럴의 타입이 변수의 타입보다 저장 범위가 넓으면 컴파일 에러가 발생한다.  
```text
float f = 3.14  // 에러. float 타입보다 double 타입의 범위가 넓다.

byte와 short 타입의 리터럴은 따로 존재하지 않으므로 int 타입의 리터럴을 사용한다. 단, 변수가 저장할 수 있는 범위에 속한 것이어야 한다.  
byte b = 65 // OK. byte 타입에 저장 가능한 범위의 int 타입 리터럴.
```

### 문자 리터럴과 문자열 리터럴
작은 따옴표 문자 하나를 감싼 것을 `문자 리터럴`이라고 한다. 두 문자 이상은 큰 따옴표로 감싸야 하며 `문자열 리터럴`이라고 한다.  
문자열을 저장하기 위해서는 String 타입을 사용해야 한다. 문자열 리터럴은 "" 안에 아무런 문자도 넣지 않는 것을 허용하며, 이를 빈 문자열이라고 한다. 
그러나 문자 리터럴은 반드시 '' 안에 하나의 문자가 있어야 한다.  
```text
String str = "";    // OK.
char ch = '';   // ERROR.
char ch = ' ';  // OK. 공백 문자로 변수 ch를 초기화.
```

원래 String은 클래스이므로 객체를 생성하는 연산자 new를 사용해야 하지만 문자열 리터럴과 같은 표현도 허용한다. 그리고 덧셈 연산자를 이용하여 문자열을 결합할 수 있다.  
덧셈 연산자(+)는 피연산자가 모두 숫자일 때는 두 수를 더하지만, 피연산자 중 어느 한 쪽이 String이면 나머지 한 쪽을 먼저 String으로 변환한 다음 두 String을 결합한다. 기본형과 참조형의 구별 없이 어떤 타입의 변수도 문자열과 덧셈 연산을 수행하면 그 결과 문자열이 된다.  

### 형식화된 출력 - printf()
printf()는 지시자를 통해 변수의 값을 여러 가지 형식으로 변환하여 출력하는 기능을 가지고 있다.  
OS마다 줄바꿈 문자가 다를 수 있기 때문에 '\n'보다 줄바꿈 지시자 '%n'을 사용하는 것이 좋다.  

### 화면에서 입력받기 - Scanner
```text
import java.util.*; // Scanner 클래스를 사용하기 위해 추가

Scanner scanner = new Scanner(System.in);   // Scanner 클래스의 객체를 생성
```
Scanner 클래스에서는 nextInt()나 nextFloat()와 같이 변환없이 숫자로 바로 입력받을 수 있는 메서드들이 있다. 이 메서드들을 사용하면 문자열을 숫자로 변환하는 수고를 하지 않아도 된다.  
그러나 이 메서드들을 화면에서 연속적으로 값을 입력받아서 사용하기에 까다롭다. 차라리 모든 값을 nextLine()으로 입력받아서 적절히 변환하는 것이 더 낫다. 
nextLine()은 입력 대기 상태에 있다가 입력을 마치고 '엔터키'를 누르면 입력한 내용이 문자열로 반환된다.  
<br>

## 진법
### 10진법과 2진법
대부분의 컴퓨터는 2진 체계로 설계되었기 때문에, 2진법을 알지 못하면 컴퓨터의 동작원리나 데이터 처리방식을 온전히 이해할 수 없다.   

### 비트(bit)와 바이트(byte)
한 자리의 2진수를 `비트(bit)`라고 하며, 1 비트는 컴퓨터가 값을 저장할 수 있는 최소단위이다. 
그러나 1 비트는 너무 작은 단위이기 때문에 1 비트 8개를 묶어서 `바이트(byte)`라는 단위로 정의해서 데이터의 기본 단위로 사용한다.  
이 외에도 `워드(word)`라는 단위가 있다. '워드'는 'CPU가 한 번에 처리할 수 있는 데이터의 크기'를 의미한다.  

### 8진법과 16진법  
2진법은 값을 표현하면 자리수가 상당히 길어진다는 단점이 있다. 이러한 단점을 보완하기 위해 2진법 대신 8진법이나 16진법을 사용한다.  
8진수는 2진수 3자리를, 16진수는 2진수 4자리를 각각 한자리로 표현할 수 있기 때문에 자리수가 짧아져서 알아보기 쉽고 서로 간의 변환방법 또한 매우 간단하다.  
<br>

## 기본형(primitive type)
### 1. 논리형 - boolean
boolean형 변수에는 true와 false 중 하나를 저장할 수 있으며 기본값은 false이다. 
두 가지의 값만을 표현하면 되므로 1 bit만으로도 충분하지만, 자바에서는 데이터를 다루는 최소단위가 byte이기 때문에, boolean의 크기가 1 byte이다.  

### 2. 문자형 - char  
문자를 저장하기 위한 변수를 선언할 때 사용되며, char 타입의 변수는 단 하나의 문자만을 저장할 수 있다.  
변수에 '문자'가 저장되는 것 같지만, 사실은 문자가 아닌 '문자의 유니코드(정수)'가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장하는 것이다. 
그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다.  

char 타입의 크기는 2 byte이므로 '0~65535' 범위의 값을 저장할 수 있다.  
컴퓨터는 숫자밖에 모르기 때문에 문자를 저장할 때는 인코딩을 해서 숫자로 변환해서 저장하고, 저장된 문자를 읽어올 때는 디코딩을 해서 숫자를 원래의 문자로 되돌린다. 
이처럼 문자를 코드로 변환하는 것을 `문자 인코딩(encoding)`이라고 하고, 그 반대로 코드를 문자로 변환하는 것을 `문자 디코딩(decoding)`이라고 한다.ㅜ
자바에서는 UTF-16을 사용한다.  

### 3. 정수형 - byte, short, int, long  
정수형에는 모두 4 개의 자료형이 있으며, 각 자료형이 저장할 수 있는 값의 범위가 서로 다르다.  
```text
byte(1 byte) < short(2 byte) < int(4 byte) < long(8 byte)
```
모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를 `부호 비트(sign bit)`로 사용하고 나머지는 값을 표현하는데 사용한다.  

정수형 변수를 선언할 때는 기본적으로 int 타입을 선택하고, int의 범위(약 ±20억)를 넘어서는 수를 다뤄야할 때는 long을 사용하면 된다.  
byte나 short보다 int를 사용하는 이유는 byte와 short는 메모리를 조금 더 절약할 수 있지만 저장할 수 있는 값의 범위가 작은 편이라서 연산 시에 범위를 넘어서 잘못된 결과를 얻기가 쉽다. 
그리고 JVM의 피연산자 스택이 피연산자를 4 Byte 단위로 저장하기 때문에 크기가 4 byte보다 작은 자료형의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 
그래서 오히려 int를 사용하는 것이 더 효율적이다.  

연산 과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 `오버플로우(overflow)`라고 한다.  
오버플로우가 발생했다고 해서 에러가 발생하는 것은 아니지만 예상했던 결과를 얻지 못하기 때문에 오버플로우가 발생하지 않도록 충분한 크기의 타입을 선택해서 사용해야 한다.  

### 4. 실수형 - float, double 
실수형은 실수를 저장하기 위한 타입으로 float와 double이 있다. 
float은 7자리의 정밀도를 가지며 double은 15자리의 정밀도를 가진다.  

실수형에서도 변수의값이 표현 범위의 최대값을 벗어나면 '오버플로우'가 발생한다. 
정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은 무한대가 된다. 
그리고 정수에는 없는 '언더플로우'가 있는데, '언더플로우'는 실수형으로 표현할 수 없는 아주 작은값이 되는 경우를 말한다. 이 때 변수의 값은 0이 된다.  

연산속도의 향상이나 메모리를 절약하려면 float를 선택하고, 더 큰 값의 범위라던가 더 높은 정밀도를 필요로 한다면 double을 선택해야 한다.  

<br>

## 형변환  
`형변환`이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것이다. 서로 다른 타입간의 연산을 수행해야하는 경우, 연산을 수행하기 전에 형변환을 통해 타입을 일치시켜야 한다.  

### 형변환 방법
```text
(타입)피연산자
```
괄호()는 '캐스트 연산자' 또는 '형변환 연산자'라고 하며, 형변환을 '캐스팅(casting)'이라고도 한다.  
형변환 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이다. 그래서 피연산자의 값은 형변환 후에도 아무런 변화가 없다.  

기본형(primitive type)에서 boolean을 제외한 나머지 타입들은 서로 형변환이 가능하다. 그리고 기본형과 참조형간의 형변환은 불가능하다.  

### 정수형간의 형변화
큰 타입에서 작은 타입으로 변환하는 경우 크기의 차이만큼 '값 손실(loss of data)'이 발생할 수 있다.  
반대로 작은 타입에서 큰 타입으로 변환하는 경우 값 손실이 발생하지 않으며 나머지 빈 공간은 0 또는 1로 채워진다. 
원래 값을 채우고 남은 빈공간은 0으로 채우는 게 보통이지만, 변환하려는 값이 음수인 경우에는 빈 공간을 1로 채운다. 
그 이유는 형변환 후에도 부호를 유지할 수 있도록 하기 위해서이다.  

### 실수형 간의 형변환  
실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다.  
float 타입의 범위를 넘는 값을 float으로 형변환하는 경우는 '±무한대' 또는 '±0'을 결과로 얻는다.  

### 정수형과 실수형 간의 형변화
정수형과 실수형은 저장형식이 완전히 다르기 때문에 정수형간의 형변화처럼 간단히 값을 채우고 자르는 식으로 할 수 없다. 좀 더 복잡한 변환과정을 거쳐야한다.  

정수형을 실수형으로 변환하는 경우, 정수는 소수점이하의 값이 없으므로 비교적 변환이 간단하다. 실수형은 정수형보다 훨씬 큰 저장범위를 갖기 때문에, 정수형을 실수형으로 변환하는 것은 별 무리가 없다. 
정수를 2진수로 변환한 다음에 정규화해서 실수의 저장형식에 맞게 저장할 뿐이다. 
살수형의 정밀도 제한으로 인해 오차가 발생할 수 있기 때문에, 10진수로 8자리 이상의 값을 실수형으로 변환할 때는 float이 아닌 double로 형변환해야 오차가 발생하지 않는다.   

실수형을 정수형으로 변환하는 경우, 실수형의 소수점 이하 값은 버려진다. 
정수형의 표현 형식으로 소수점 이하의 값은 표현할 수 없기 때문이다. 
그래서 실수형을 정수형으로 형변환할 때 반올림이 발생하지 않는다. 
만일 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에는 정수의 오버플로우가 발생하는 결과를 얻는다.  

### 자동 형변환  
서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙이지만 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다. 
컴파일러가 생략된 형변환을 자동적으로 추가한다.  

그러나 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형 변환을 생략하면 에러가 발생한다.  
이떄, 명시적으로 형변환 해줬을 경우, 형변환이 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.  
이처럼 연산과정에서 자동적으로 발생하는 형변환을 '산술 변환'이라고 한다.  

컴파일러가 생략된 형변환을 자동적으로 추가할 때 컴파일러는 다음과 같은 기준으로 타입을 일치시킨다.  
```text
기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.
```
<img width="952" alt="스크린샷 2022-12-30 오전 12 30 55" src="https://user-images.githubusercontent.com/54930365/209974979-e83fa915-b2eb-4318-968e-ced04913f31e.png">
다음 그림은 형변환이 가능한 7개의 기본형을 왼쪽부터 오른쪽으로 표현할 수 있는 값의 범위가 작은 것부터 큰 것의 순서로 나열한 것이다.  
화살표 방향으로의 변환, 즉 왼쪽에서 오른쪽으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되며, 그 반대 방향으로의 변환은 반드시 형변환 연산자를 써줘야 한다.  

실수형은 정수형과 값을 표현하는 방식이 다르기 때문에 같은 크기일지라도 실수형이 정수형보다 훨씬 더 큰 표현 범위를 갖기 때문에 float과 double이 같은 크기인 int와 long보다 오른쪽에 위치한다.  
chart와 short는 둘 다 2 byte의 크기로 크기가 같지만, 서로 범위가 달라서 둘 중의 어느 쪽으로의 형변환도 값 손실이 발생할 수 있으므로 자동 형변환이 수행될 수 없다.  
```text
1. boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.
2. 기본형과 참조형은 서로 형변환할 수 없다.
3. 서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.
```