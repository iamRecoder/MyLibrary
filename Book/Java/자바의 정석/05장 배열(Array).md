CH05. 배열
====
## 배열
배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것을 의미한다.  

### 배열의 생성  
배열을 생성하기 위해서는 연산자 'new'와 함께 배열의 타입과 길이를 지정해 주어야 한다.  
```java
    타입[] 변수이름;  // 배열을 선언 (배열을 다루기 위한 참조변수 선언)
    변수이름 = new 타입[길이];  // 배열을 생성 (실제 저장공간을 생성)
```  

### 배열 길이와 인덱스   
인덱스는 배열의 요소마다 붙여진 일련번호로 각 요소를 구별하는데 사용된다. 
유효하지 않은 범위의 값을 index로 사용하면 실행 시에 에러(ArrayIndexOutOfBoundsException)가 발생한다.  

### 배열의 길이  
배열을 생성할 때 괄호[] 안에 배열의 길이를 적어줘야 하는데, 배열의 길이는 배열의 요소의 개수, 즉 값을 저장할 수 있는 공간의 개수다.  
배열의 길이는 양의 정수여야 하며 최대값은 int 타입의 최대값, 약 20억이다.  
길이가 0인 배열도 생성 가능하다.  
`ex) int[] arr = new int[0];`  

### 배열이름.length  
자바에서는 jVM이 모든 배열의 길이를 별도로 관리하며, `배열이름.length`를 통해서 배열의 길이에 대한 정보를 얻을 수 있다.  
배열은 한번 생성하면 길이를 변경할 수 없기 때문에, 이미 생성된 배열의 길이는 변하지 않는다.  
따라서 `배열이름.length`는 상수이다. 즉, 값을 읽을 수만 있을 뿐 변경할 수 없다.  

### 배열의 길이 변경하기  
배열은 한번 선언되고 나면 길이를 변경할 수 없다고 배웠는데, 그렇다면 배열에 저장할 공간이 부족한 경우에는 어떻게 해야 할까?  
```text
배열의 길이를 변경하는 방법: 
1. 더 큰 배열을 새로 생성한다.  
2. 기존 배열의 내용을 새로운 배열에 복사한다.
```
이러한 작업들은 꽤나 비용이 많이 들기 때문에, 처음부터 배열의 길이를 넉넉하게 잡아줘서 새로 배열을 생성해야하는 상황이 가능한 적게 발생하도록 해야 한다.  

### 배열의 초기화  
배열은 생성과 동시에 자동적으로 자신의 타입에 해당하는 기본값으로 초기화되므로 배열을 사용하기 전에 따로 초기화를 해주지 않아도 된다.  
또한 다음과 같이 값을 지정하여 초기화할 수 있다.  
```java
// 배열의 선언과 생성을 같이 하는 경우
int[] score = new int[] {50, 60, 70, 80, 90};   // OK.
int[] score = {50, 60, 70, 80, 90}; // OK. new int[]를 생략 가능할 수 있음

// 배열의 선언과 생성을 따로 하는 경우
int[] score;        
score = new int[] {50, 60, 70, 80, 90}; // OK.
score = {50, 60, 70, 80, 90};   // ERROR. new int[]를 생략 가능할 수 없음

// 메서드의 매개변수로 배열을 받는 경우
int result = add(new int[] {50, 60, 70, 80, 90});   // OK.
int reault = add({50, 60, 70, 80, 90}); // ERROR. new int[]를 생략할 수 없음.
``` 

그리고 괄호{} 안에 아무 것도 넣지 않으면 길이가 0인 배열이 생성된다. 
참조변수의 기본 값은 null이지만, 배열을 가리키는 참조변수는 null대신 길이가 0인 배열로 초기화하기도 한다.  
```java
int[] score = new int[0];   // 길이가 0인 배열
int[] score = new int[]{};  // 길이가 0인 배열
int[] score = {};           // 길이가 0인 배얼. new int[]가 생략됨.
```

### 배열의 출력  
`Arrays.toString(배열이름)` 메서드를 사용하면 '[첫번째 요소, 두번째 요소, ...]'와 같은 형식의 문자열로 만들어서 반환한다.  
배열은 참조변수이므로 배열을 출력하면 '배열의 주소'가 출력될 것 같지만 실제로는 '타입@주소'의 형식으로 출력된다. 
'@'뒤에 나오는 16진수는 배열의 주소인데 실제 주소가 아닌ㄴ 내부 주소이다.  
```java
int[] iArr = { 100, 95, 80, 70, 60};
System.out.println(Arrays.toString(iArr));  // [100, 95, 80. 70, 60]이 출력된다. 'import java.util.*' 필요.
System.out.println(iArr);                   // [[I@14318bb와 같은 형식의 문자열이 출력된다.
```

예외적으로 char 배열은 println 메서드로 출력하면 각 요소가 구분자 없이 그대로 출력된다. 
이것은 println 메서드가 char배열일 때만 이렇게 동작하도록 작성되었기 때문이다.  
```java
char[] chArr = {'a', 'b', 'c', 'd'};
System.out.println(chArr);  // abcd가 출력된다.
```  

### 배열의 복사
배열을 복사하는 방법은 두 가지가 있다.  
1. for문을 이용한 배열의 복사    
2. System.arraycopy()를 이용한 배열의 복사  
   ```java
    System.arraycopy(num, 0, newNum, 0, num.length);
    // num[0]에서 newNum[0]으로 num.length개의 데이터를 복사. 이때 복사하려는 내용보다 여유 공간이 적으면 에러(ArrayIndexOutOfBoundsException)가 발생한다.
    ```

for문 대신 System 클래스의 arraycopy()를 사용하면 보다 간단하고 빠르게 배열을 복사할 수 있다. 
for문은 배열의 요소 하나하나에 접근해서 복사하지만, arraycopy()는 지정된 범위의 값들을 한 번에 통째로 보사한다.  




