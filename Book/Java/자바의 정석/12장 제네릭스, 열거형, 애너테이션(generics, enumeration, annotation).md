# CH12. 지네릭스, 열거형, 애너테이션

## 지네릭스(Generics)  
지네릭스는 JDK1.5에서 처음 도입되었다.  

<br>

### 지네릭스란  
지네릭스는 `다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능`이다. 
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.  

예를 들어, ArrayList와 같은 컬렉션 클래스는 다양한 종류의 객체를 담을 수 있긴 하지만 보통 한 종류의 객체를 담는 경우가 더 많다. 
그런데도 꺼낼 때 마다 타입체크를 하고 형변환을 하는 것은 아무래도 불편할 수밖에 없다. 
게다가 원하지 않는 종류의 객체가 포함되는 것을 막을 방법이 없다는 것도 문제다. 이러한 문제들을 지네릭스가 해결해준다.  

> 지네릭스의 장점  
> 1. 타입 안정성을 제공한다.
> 2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.  

<br>

### 지네릭 클래스의 선언  
클래스를 지네릭 클래스로 변경하면 클래스 옆에 `<T>`를 붙이고 'Object'를 모두 `T`로 바꾸면 된다.  
```java
class Box<T> {   // 지네릭 타입 T를 선언  
    T item;   
    void setItem(T item){ this.item = item; }
    T getItem(){ return item; }
}
```

<br>

`T`를 '타입 변수(type variable)'라고 하며, 'Type'의 첫글자에서  따온 것이다. 
타입 변수는 T가 아닌 다른 것을 사용해도 된다.  
ArrayList<E>와 Map<K,V>와 같이 무조건 'T'를 사용하기보다는 상황에 맞게 의미있는 문자를 선택해서 사용하는 것이 좋다.  

**이들은 기호의 종류만 다를 뿐 `임의의 참조형 타입`을 의미한다는 것은 모두 같다.**   
지네릭이 도입되기 이전의 코드와 호환을 위해, 지네릭 클래스인데도 예전의 방식으로 객체를 생성하는 것이 허용된다. 
다만, 지네릭 타입을 지정하지 않아서 안전하지 않다는 경고가 발생한다.  
```java
Box b1 = new Box();         // OK. T는 Object로 간주된다. 
b1.setItem(new Object());   // 경고. unchecked or unsafe operation

Box<Object> b2 = new Box<Object>();         // OK. T 대신 Object 타입을 지정
b2.setItem(new Object());   // 경고 발생 안함. 타입을 지정하지 않은 것이 아니라 알고 적은 것이기 때문.        

Box<String> b3 = new Box<String>(); // 타입 T 대신, 실제 타입을 지정
b3.setItem(new Object());   // 에러. String 타입 이외의 타입은 지정 불가.
b3.setItem("ABC");          // OK. String 타입이므로 가능
```

<br>

#### 지네릭스 용어  
`Class Box<T> {}`  
```text
Box<T>    지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.  
T         타입 변수 또는 타입 매개변수.(T는 타입 문자)   
Box       원시 타입(raw type)   
```
타입 변수 또는 타입 매개변수는 메서드의 매개변수와 유사한 면이 있다. 그래서 타입 매개변수에 타입을 지정하는 것을 `지네릭 타입 호출`이라고 하고, 
지정된 타입 'String'을 `매개변수화된 타입`이라고 한다.  

Box<String>과 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 
이 둘이 별개의 클래스를 의미하는 것은 아니다. 
이는 마치 매개변수의 값이 다른 메서드 호출, 즉 add(3,5)와 add(2,4)가 서로 다른 메서드를 호출하는 것이 아닌 것과 같다.  

<br>

#### 지네릭스의 제한  
지네릭스는 인스턴스별로 다르게 동작하도록 하기 위해 만들어진 기능이다. 
그래서 지네릭 클래스 Box의 객체를 생성할 때, 객체별로 다른 타입을 지정하는 것은 적절하다.  
그러나 모든 객체에 대해 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없다. 
T는 인스턴스변수로 간주되기 때문이다. 앞에서 배웠듯이 static 멤버는 인스턴스변수를 참조할 수 없다.   
static 멤버는 타입 변수에 지정된 타입, 즉 대입된 타입의 종류에 관계없이 동일한 것이어야 한다.  

그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. 
지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만, 'new T[10]'과 같이 배열을 생성하는 것은 안된다는 뜻이다. 
```java
T[] itemArr;    // OK. T타입의 배열을 위한 참조변수
T[] tmpArr new T[3];    // 에러. 지네릭 배열 생성불가  
```

지네릭 배열을 생성할 수 없는 이유는 new 연산자 때문이다. 
이 연산자는 컴파일 시점에 타입 T가 무엇인지 정확히 알아야 한다. 그런데 지네릭 클래스를 컴파일하는 시점에서 T가 정확히 어떤 타입이 될지 전혀 알 수 없다.  
더하여, instanceof 연산자도 new 연산자와 같은 이유로 T를 피연산자로 사용할 수 없다.  

꼭 지네릭 배열을 생성해야할 필요가 있을 때는, new 연산자 대신 'Reflection API'의 newInstance()와 같이 
동적으로 객체를 생성하는 메서드로 배열을 생성하거나, Object 배열을 생성해서 복사한 다음에 'T[]'로 형변환하는 방법 등을 사용한다.  

<br><br>

### 지네릭 클래스의 객체 생성과 사용  
지네릭 클래스의 객체를 생성할 때는 참조변수와 생성자에 대입된 타입(매개변수화된 타입)이 일치해야 한다. 
일치하지 않으면 에러가 발생한다.  
두 타입이 상속관계에 있어도 마찬가지이다.  
단, 두 지네릭 클래스의 타입이 상속관계에 있고, 대입된 타입이 같은 것은 괜찮다.  
```java
Box<Apple> appleBox = new Box<Apple>();     // OK.
Box<Apple> appleBox = new Box<Grape>();     // 에러. 참조변수와 생성자에 대입된 타입이 불일치

Box<Fruit> appleBox = new Box<Apple>();     // 에러. Apple이 Fruit의 자손이더라도 참조변수와 생성자에 대입된 타입이 불일치하기 때문

Box<Apple> appleBox = new FruitBox<Apple>();    // OK. 다형성. FruitBox는 Box의 자손이다.
```

<br>

JDK1.7부터는 추정이 가능한 경우 타입을 생략할 수 있게 되었다. 
참조변수의 타입으로 생성자의 타입을 유추할 수 있기 때문에 생성자에 반복해서 타입을 지정해주지 않아도 되는 것이다.  
```java
Box<Apple> appleBox = new Box<>();      // OK. JDK1.7부터 생략 가능
```

<br>

생성된 Box<T>의 객체에 'void add(T item)'으로 객체를 추가할 때, 대입된 타입과 다른 타입의 객체는 추가할 수 없다.  
그러나 타입 T의 자손들은 이 메서드의 매개변수가 될 수 있다.  
```java
Box<Apple> appleBox = new Box<Apple>();
appleBox.add(new Apple());  // OK.
appleBox.add(new Grape());  // 에러. Box<Apple>에는 Apple 객체만 추가 가능
appleBox.add(new GreenApple()); // OK. 다형성. GreenApple은 Apple의 자손이다. 
```

<br><br>

### 제한된 지네릭 클래스  
지네릭 타입에 `extends`를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.  
```java
class FruitBox<T extends Fruit> {
    ...
}
```

<br>

만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이때도 `extends`를 사용한다. 
`implements`를 사용하지 않는다는 점에 주의하자.  

클래스 Fruit의 자손이면서 Eatable 인터페이스도 구현해야한다면 아래와 같이 `&` 기호로 연결한다.  
이제 FruitBox에는 Fruit의 자손이면서 Eatable을 구현한 클래스만 타입 매개변수 T에 대입될 수 있다.  
```java
class FruitBox<T extends Fruit & Eatable> {
    ...
}
```

<br>
<br>

### 와일드 카드  
지네릭 클래스라 하더라도 static 메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없으므로 특정 타입을 T 대신 지정해줘야 한다.  
이렇게 지네릭 타입 대신 특정 타입으로 매개변수를 지정할 경우, 다른 타입의 객체는 static 메서드의 매개변수가 될 수 없다.  
```java
static Juice makeJuice(FruitBox<T> box){ ... }          // static 메서드에는 타입 매개변수 T를 매개변수에 사용할 수 없다.  
static Juice makeJuice(FruitBox<Fruit> box){ ... }      // 따라서, static 메서드에 지네릭스를 사용할 경우, 타입 매개변수 T 대신 특정 타입을 지정해줘야 한다.
```

<br>

```java
static Juice makeJuice(FruitBox<Fruit> box){ ... }
static Juice makeJuice(FruitBox<Apple> box){ ... }
```
그러나 위의 예시처럼 지네릭 타입이 다르게 오버로딩하면, 컴파일 에러가 발생한다. **지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문이다.**  
지네릭 타입은 컴파일러가 컴파일할 때만 사용하고 제거해버린다. 그래서 위의 두 메서드는 오버로딩이 아니라 `메서드 중복 정의`이다.  

이럴 때 사용하기 위해 고안된 것이 바로 `와일드 카드`이다.  
와일드카드는 기호 '?'로 표현하는데, 와일드 카드는 어떠한 타입도 될 수 있다.  
