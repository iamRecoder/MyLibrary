CH03. 연산자
======
## 연산자
연산자는 '연산을 수행하는 기호'이다.  
연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.  

### 연산자 종류
- 산술 연산자 : 사칙 연산(+,-,*,/)과 나머지(%) 연산
- 비교 연산자 : 크고 작음과 같고 다름을 비교
- 논리 연산자 : 그리고(AND)와 또는(OR)으로 조건을 연결
- 대입 연산자 : 우변의 값을 좌변에 저장
- 기타 : 형변환 연산자, 삼항 연산자, instanceof 연산자
```text
산술 연산자 : + , - , * , / % , << , >>   
비교 연산자 : > , < , >= , <= , == , !=
논리 연산자 : && , || , ! , & , | , ^ , ~
대입 연산자 : =
기타 : (type) , ?: , instanceof
```

### 연산자의 우선순위와 결합규칙
주의해야 할 연산자 우선순위의 예와 설명
```text
x << 2 + 1
쉬프트 연산자(<<)는 덧셈 연산자보다 우선순위가 낮다. 그래서 'x << (2+1)'과 같다.

data & 0xFF == 0
비트 연산자(&)는 비교 연산자(==)보다 우선순위가 낮으므로 비교연산 후에 비트연산이 수행된다. 그래서 왼쪽의 식은 'data & (0xFF == 0)'과 같다.

x < -1 || x > 3 && x < 5
논리 연산자 중에서 AND를 의미하는 '&'와 '&&'가 OR를 의미하는 '|'와 '||'보다 우선순위가 높다. 
이처럼 수식에 AND와 OR가 함께 사용되는 경우는 다음과 같이 괄호를 사용해서 우선순위를 명확히 하는 것이 좋다. x < -1 || (x>>3 && x<5)
```

연산자의 우선순위에 대해 정리하면 다음과 같다.  
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산자의 진행 방향은 왼쪽에서 오른쪽이다.

### 산술 변환  
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.  
연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 `산술 변환` 또는 `일반 산술 변환`이라 하며, 이 변환은 아항 연산에서만 아니라 단항 연산에서도 일어난다. 
모든 연산에서 `산술 변환`이 일어나지만, 쉬프트 연산자(<<,>>), 증감 연산자(++,--)는 예외이다.  

`산술 변환`의 규칙은 다음과 같다.  
1. 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)  
   : 피연산자의 값손실을 최소화하기 위해서이다.
   
2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.  
   : 정수형의 기본 타입인 int가 가장 효율적으로 처리할 수 있는 타입이기 때문이다.  

크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환되지만, 반대로 큰 자료형의 값을 작은 자료형의 변수에 저장하려면 명시적으로 형변환 연산자를 사용해서 변환해주어야 한다.  
```ex) byte c = a + b; // 컴파일 에러 발생. 명시적으로 형변환 필요. byte c = (byte)(a + b)```


### 나머지 연산자 %
나머지 연산자(%)는 나누는 수로 음수도 허용한다. 그러나 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 결과가 같다.  
그냥 피연산자의 부호를 모두 무시하고, 나머지 연산을 한 결과에 왼쪽 피연산자(나눠지는 수)의 부호를 붙이면 된다.  

### 비교 연산자  
비교 연산의 결과는 오직 true와 false 둘 중의 하나이다. 
비교 연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이  서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다.  

float 타입과 double 타입의 값을 올바르게 비교하기 위해서는 double 타입의 값을 float 타입으로 형변환한 다음에 비교해야 한다. 그래야만 올바른 결과를 얻을 수 있다. 
또는 어느 정도의 오차는 무시하고 두 타입의 값을 앞에서 몇 자리만 잘라서 비교할 수 있다.  

### 문자열의 비교  
두 문자열을 비교할 때는 비교 연산자 '==' 대신 equals()라는 메서드를 사용해야 한다. 
'=='는 같은 객체인지 확인하지만 equals()는 객체가 달라도 내용이 같으면 true를 반환한다.  
만일 대소문자를 구분하지 않고 비교하고 싶으면, equals() 대신 equalsIgnoreCase()를 사용하면 된다.  

### 논리 연산자  
```text
||(OR 결합) : 피연산자 중 어느 한 쪽만 true이면 true를 결과로 얻는다.
&&(AND 결합) : 피연산자 양쪽 모두 true이어야 true를 결과로 얻는다. &&가 ||보다 우선순위가 높다. 
```

논리 연산자는 효율적인 연산을 한다. '||(OR)' 연산의 경우, 두 피연산자 중 어느 한쪽만 '참'이어도 전체 연산결과가 '참'이므로 좌측 피연산자가 'true'이면 우측 피연산자의 값은 평가하지 않는다. 
'&&(AND)' 연산의 경우, 어느 한쪽만 '거짓'이어도 전체 연산결과가 '거짓'이므로 좌측 피연산자가 '거짓'이면 우측 피연산자는 평가하지 않는다.  
그래서 같은 조건식이라도 피연산자의 위치에 따라서 연산속도가 달라질 수 있는 것이다.  

'||(OR)' 연산의 경우에는 연산결과가 '참'일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.  
'&&(AND)' 연산의 경우에는 연산결과가 '거짓'일 확률이 높은 피연산자를 연산자의 왼쪽에 놓아야 더 빠른 연산결과를 얻을 수 있다.  


### 비트 연산자 
비트 연산자는 피연산자를 비트단위로 논리 연산한다.  
```text
| (OR 연산자) : 피연산자 중 한 쪽의 값이 1이면, 1을 결과로 얻는다. 그 외에는 0을 얻는다.
& (AND 연산자) : 피연산자 양 쪽이 모두 1이어야만 1을 결과로 얻는다. 그 외에는 0을 얻는다.
^ (XOR) : 피연산자의 값이 서로 다를 때만 1을 결과로 얻는다. 같을 때는 0을 얻는다.
~ (비트 전환 연산자) : 0은 1로 1은 0으로 바꾼다. 부호가 있는 타입의 피연산자는 부호가 반대로 변경된다.(피연산자의 1의 보수를 얻을 수 있다.)
```

### 쉬프트 연산자  
```text
x << n은 x * 2ⁿ의 결과와 같다.
x >> n은 x / 2ⁿ의 결과와 같다.
```
쉬프트 연산에서 n의 값이 자료형의 bit수 보다 크면,자료형의 bit 수로 나눈 나머지만큼만 이동한다.  
`ex) 8 >> 34   // 8 >> 2가 수행된다. `  

쉬프트 연산자는 다른 이항연산자들과 달리 피연산자의 타입을 일치시킬 필요가 없기 때문에 우측 피연산자에는 산술변환이 적용되지 않는다.  
쉬프트 연산은 가독성은 떨어지지만 나눗셈 또는 곱셈 연산자를 사용하는 것보다 더 빠르다.  

