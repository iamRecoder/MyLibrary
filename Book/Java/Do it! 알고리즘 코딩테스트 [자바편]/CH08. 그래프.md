# CH08. 그래프
그래프는 노드와 에지로 구성된 집합이다.  
노드는 데이터를 표현하는 단위이고 에지는 노드를 연결한다. 9장에서 공부할 트리도 그래프의 일종이다.  
그래프는 여러 알고리즘에 많이 사용되는 자료구조이므로 코딩 테스트에 자주 등장한다.  

- 유니온 파인드: 그래프의 사이클이 생성되는지 판별하는 알고리즘
- 위상 정렬: 사이클이 없고 방향이 있는 그래프를 정렬. 정렬 결과가 한 개 이상이다. (ex. 수강신청)
- 다익스트라: 최단 거리 알고리즘. 간선의 가중치가 음수이면 안된다.
- 벨만-포드: 최단 거리 알고리즘. 간선의 가중치가 음수여도 된다.
- 플로이드-워셜: 최단 거리 알고리즘. 시작 노드가 정해져 있지 않다. 다익스트라, 벨만-포드에 비해 시간복잡도가 좋지 않다.
- 최소 신장 트리: MST. 최소 가중치를 갖는 트리. 유니온 파인드를 이용해서 사이클이 발생하는 지 확인한다.

<br><br>

## 08-1. 그래프의 표현
그래프를 구현하는 3가지 방법을 알아보자.  

1. 에지 리스트
   - 에지 리스트는 에지를 중심으로 그래프를 표현한다.  
   - 에지 리스트는 배열에 출발 노드, 도착 노드 또는 출발 노드, 도착 노드, 가중치를 저장하여 에지를 표현한다.

2. 인접 행렬
   - 인접 행렬은 2차원의 자료구조를 이용하여 그래프를 표현한다.
   - 인접 행렬은 에지 리스트와 다르게 노드 중심으로 그래프를 표현한다.  
   - 인접 행렬을 이용한 그래프 구현은 쉽다. 두 노드를 연결하는 에지의 여부와 가중치값은 배열에 직접 접근하면 바로 확인할 수 있다.
   - 그러나 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 비해 에지가 적을 때는 공간 효율성이 떨어진다.

3. 인접 리스트(제일 중요!!)
   - 인접 리스트는 ArrayList로 그래프를 표현한다.
   - 노드의 개수만큼 ArrayList를 선언한다. ex) ArrayList<Integer>[5]
   - 노드 별로 에지 개수가 일정하기 때문에 가변적인 ArrayList를 사용하면 공간 낭비를 줄일 수 있다.
   - 만약 가중치가 있는 경우라면 (도착 노드, 가중치)를 갖는 Node 클래스를 선언하여 ArrayList에 사용한 것이다.  ex) ArrayList<Node>[N]
   - 그래프 구현은 복잡한 편이지만 노드와 연결되어 있는 에지를 탐색하는 시간은 매우 뛰어나며, 노드 개수가 커도 공간 효율이 좋아 메모리 초과 에러도 발생하지 않는다.
   - 이런 장점으로 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호한다.  


<br><br>

## 08-2. 유니온 파인드
유니온 파인드는 일반적으로 여러 노드가 있을 떄 특정 2개의 노드를 연결해 1개의 잡합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성되어 있는 알고리즘이다.  

- 유니온 파인드의 핵심 이론
  - union 연산: 각 노드가 속한 집합을 1개로 합치는 연이다. 다른 집합에 속한 두 개의 노드를 하나의 집합으로 합친다.
  - find 연산: 특정 노드a에 대해 a가 속한 집합의 대표 노드를 반환하는 연산이다. 

- 유니온 파인드의 작동 원리
  유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다. 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다. 각 노드가 모두 대표 노드이므로 배열은 자신의 인덱스 값으로 초기화된다.
  2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 유니온 연산을 수행한다.
  - union 연산:
    find 연산을 수행 후, 두 노드의 루트 노드 값이 다르다면 union 연산을 수행한다.
  - find 연산: 
    1. 대상 노드 배열에 index 값과 value 값이 동일한지 확인한다.
    2. 동일하지 않으면 value 값이 가리키는 index 위치로 이동한다.
    3. 이동 위치의 index 값과 value 값이 같을 때까지 1,2번 단계를 반복한다. 반복이므로 이 부분은 재귀 함수로 구현한다.
    4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경한다.


<br><br>

## 08-3. 위상 정렬
위상 정렬은 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘이다.  

|기능|특징|시간 복잡도(노드 수: V, 에지 수: E)|
|:---|:---|:---|
|노드 간의 순서를 결정|사이클이 없어야 함|O(V + E)|

위상정렬에서는 항상 유일한 값으로 정렬되지 않는다. 또한 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.  

- 위상 정렬의 핵심 이론
  1. 진입 차수를 이해해보자. 진입 차수는 자기 자신을 가리키는 에지의 개수이다.  
     <img width="394" alt="스크린샷 2023-03-25 오전 2 06 59" src="https://user-images.githubusercontent.com/54930365/227593409-bd85326e-498f-4ddd-8e0a-20851d7ce9e7.png">
  2. 진입 차수 배열에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 배열에 저장한다. 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다.  
     <img width="379" alt="스크린샷 2023-03-25 오전 2 08 48" src="https://user-images.githubusercontent.com/54930365/227593796-181e3939-f8d8-4a6b-ab91-842d77467426.png">


<br><br>

## 08-4. 다익스트라
다익스트라 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.  

|기능|특징|시간 복잡도(노드 수: V, 에지 수: E)|
|:---|:---|:-----------------------|
|출발 노드와 모든 노드 간의 최단 거리 탐색|에지는 모두 양수| O(ElogV)               |

특정 노드에서 다른 노드들의 최단 거리를 구하는 문제가 주어졌을 때 다익스트라 알고리즘을 사용하면 문제를 해결할 수 있다.  

- 다익스트라 알고리즘의 핵심 이론
1. 안접 리스트로 그래프 구현하기 
  다익스트라 알고리즘은 인접 행렬로 구현해도 좋지만 시간 복잡도 측면, N의 크기가 클 것을 대비해 인접 리스트를 선택하여 구현하는 것이 좋다.  
  그래프의 연결을 표현하기 위해 인접 리스트에 연결한 배열의 자료형은 (노드, 가중치)와 같은 형태로 선언하여 연결한다.  
2. 최단 거리 배열 초기화하기  
  최단 거리 배열을 만들고, 출발 노드는 0, 이외의 노드는 무한으로 초기화한다.   
  이때 무한은 적당히 큰 값을 사용하면 된다.  
3. 값이 가장 작은 노드 고르기  
  최단 거리 배열에서 현재 값이 가장 작은 노드를 고른다.  
4. 최단 거리 배열 업데이트하기  
  선택된 노드에 연결된 에지의 값을 바탕으로 다른 노드의 값을 업데이트한다.  
  1단계에서 저장해 놓은 연결 리스트를 이용해 현재 선택된 노드의 에지들을 탐색하고 업데이트하면 된다 연결 노드의 최단 거리는 다음 두 값 중 더 작은 값으로 업데이트한다.  
  > 최단 거리 업데이트 방법  
  > Min(선택 노드의 최단 거리 배열의 값 + 에지 가증치, 연결 노드의 최단 거리 배열의 값)  
  <img width="442" alt="스크린샷 2023-03-27 오전 1 58 51" src="https://user-images.githubusercontent.com/54930365/227791724-aadca27b-7389-4c2d-9fcf-67016570320c.png">

5. 과정 3 ~ 4를 반복해 최단 거리 배열 완성하기  
  모든 노드가 처리될 때까지 과정 3 ~ 4를 반복한다. 과정 4에서 선택 노드가 될 때마다 다시 선택되지 않도록 방문 배열을 만들어 처리하고, 모든 노드가 선택될 때까지 반복하면 최단 거리 배열이 완성된다.  
   <img width="383" alt="스크린샷 2023-03-27 오전 1 57 47" src="https://user-images.githubusercontent.com/54930365/227791679-82bdf247-541f-420e-a1b7-3eda4d538e0d.png">

다시 한번 정리하면 다익스트라 알고리즘은 출발 노드와 그외 노드 간의 최단 거리를 구하는 알고리즘이고, 에지는 항상 양수여야 한다는 제약 조건이 있다.  
많은 사람이 다익스트라 알고리즘이 출발 노드와 도착 노드의 최단 거리를 구하는 알고리즘이라고 생각하는 경향이 있는데, 실제로 완성된 배열은 **출발 노드와 이외의 모든 노드 간의 최단 거리**를 표현한다.  


<br><br>

## 08-5. 벨만-포드
벨만-포드 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.  

|기능|특징|시간 복잡도(노드 수: V, 에지 수: E)|
|:---|:---|:---|
|특정 출발 노드에서 다른 모든 노드까지의 최단 경로 탐색|- 음수 가중치 에지가 있어도 수행할 수 있음<br>- 전체 그래프에서 음수 사이클의 존재 여부를 판단할 수 있음|O(VE)|


- 밸만-포드의 핵심 이론
1. 에지 리스트로 그래프를 구현하고 최단 경로 리스트 초기화하기  
   벨만-포드 알고리즘은 에지를 중심으로 동작하므로 그래프를 에지 리스트로 구현한다. 
   또한 최단 경로 리스트를 출발 노드는 0, 나머지 노드는 무한대로 초기화한다.  
   <img width="375" alt="스크린샷 2023-03-27 오전 2 14 42" src="https://user-images.githubusercontent.com/54930365/227792511-8809809b-2db7-4528-879e-257b29752453.png">

2. 모든 에지를 확인해 정답 리스트 업데이트하기  
  최단 거리 리스트에서 업데이트 반복 횟수는 노드 개수 - 1입니다.(사이클이 없어야 하기 때문)    
  노드 개수가 N이고, 음수 사이클이 없을 때 특정 두 노드의 최단 거리를 구성할 수 있는 에지의 최대 개수는 N-1이기 때문이다.  
  모든 에지 E=(s, e, w)에서 다음 조건을 만족하면 업데이트를 실행한다.  
  업데이트 반복 횟수가 K번이라면 해당 시점에 정답 리스트의 값은 시작점에서 K개의 에지를 사용했을 때 각 노드에 대한 최단 거리이다.  
  > 업데이트 조건과 방법   
  > `D[s]!=무한`이며 D[e] > D[s] + w일 때 D[e] = D[s] + w로 리스트의 값을 업데이트 한다.(새로운 값이 더 작으면 새로운 값으로 업데이트 한다.)   
  <img width="377" alt="스크린샷 2023-03-27 오전 2 21 00" src="https://user-images.githubusercontent.com/54930365/227792878-7681ba49-4432-4584-9e02-2553fd418e16.png">
  <img width="470" alt="스크린샷 2023-03-27 오전 2 22 47" src="https://user-images.githubusercontent.com/54930365/227792972-f81f0bf9-2629-4ec4-887a-649f89c1a26c.png">
  음수 사이클이 없을 때 N-1번 에지 사용 횟수를 반복하면 출발 노드와 모든 노드 간의 최단 거리를 알려 주는 정답 리스트가 완성된다. 이렇게 완성 후 마지막으로 이 그래프에 음수 사이클이 존재하는 지 확인해야 한다.  

3. 음수 사이클 유무 확인하기  
  음수 사이클 유무를 확인하기 위해 모든 에지를 한 번씩 다시 사용해 업데이트되는 노드가 발생하는지 확인한다.  
  만약 업데이트되는 노드가 있다면 음수 사이클이 있다는 뜻이 되고, 2 단계에서 도출한 정답 리스트가 무의미하고 최단 거리를 찾을 수 없는 그래프라는 뜻이 된다.  
  음수 사이클이 존재하면 이 사이클을 무한하게 돌수록 가중치가 계속 감소하므로 최단 거리를 구할 수 없다.  
   <img width="433" alt="스크린샷 2023-03-27 오전 2 31 18" src="https://user-images.githubusercontent.com/54930365/227793429-60850435-b17b-43db-8aac-d5a6c43911d7.png">

실제 알고리즘 코딩 테스에서는 벨만-포드 알고리즘을 사용해 최단 거리를 구하는 문제보다 음수 사이클을 판별하는 문제가 더 빈번하게 출제된다.  
따라서 마지막에 한 번 더 모든 에지를 사용해 업데이트되는 노드가 존재하는지 확인해야 한다.  

<br><br>

## 08-6. 플로이드-워셜
플로이드-워셜 알고리즘은 그래프에서 최단 거리를 구하는 알고리즘으로, 주요 특징은 다음과 같다.  

|기능|특징| 시간 복잡도 |
|:----|:---|:-------|
|모든 노드 간에 최단 경로 탐색|- 음수 가중치 에지가 있어도 수행할 수 있음<br>- 동적 계획법의 원리를 이용해 알고리즘에 접근| O(V^3) |

- 플로이드-워셜의 핵심 이론  
플로이드-워셜 알고리즘을 도출하는 가장 핵심적인 원리는 A 노드에서 B 노드까지 최단 경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 부분 경로 역시 최단 경로라는 것이다.  

색칠된 에지 경로가 1->5 최단 경로라면 1->4 최단 경로와 4->5 최단 경로 역시 색칠된 에지로 이루어질 수밖에 없다.  
즉, 전체 경로의 최단 경로는 부분 경로의 최단 경로의 조합으로 이루어진다.  

> 도출한 플로이드-워셜 점화식   
> ```D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])```    // S와 E 사이의 모든 노드를 거치는 경우를 비교해서 최소값을 구한다.

플로이드-워셜 알고리즘 구현 방법은 다음과 같다.  
1. 리스트를 선언하고 초기화하기  
  D[S][E]는 노드 S에서 노드 E까지의 최단 거리를 저장하는 리스트라 정의한다.  
  S와 E의 값이 같은 칸은 0, 다른 칸은 무한으로 초기화한다. 여기에서 S == E는 자기 자신에게 가는 데 걸리는 최단 경로값을 의미하기 때문이다.  
   <img width="449" alt="스크린샷 2023-03-28 오전 7 18 58" src="https://user-images.githubusercontent.com/54930365/228079579-df5f5883-d998-4990-8acb-917ff88cffb5.png">

2. 최단 거리 리스트에 그래프 데이터 저장하기
  출발 노드는 S, 도착 노드는 E, 이 에지의 가중치는 W라고 했을 때 D[S][E] = W로 에지의 정보를 리스트에 입력한다.  
  이로써 플로이드-워셜 알고리즘은 그래프를 인접 행렬로 표현한다는 것을 알 수 있다.  
   <img width="351" alt="스크린샷 2023-03-28 오전 7 20 46" src="https://user-images.githubusercontent.com/54930365/228079861-3d25e080-f22f-4d7e-8ded-18955c63719d.png">

3. 기존에 구했던 점화식을 3중 for문의 형태로 반복하면서 리스트의 값을 업데이트한다.  
  > 플로이드-워셜 알고리즘 로직  
  > ```java
  > for 경유지 K에 관해 (1 ~ N)   // N: 노드 개수
  >   for 출발 노드 S에 관해 (1 ~ N)
  >     for 도착 노드 E에 관해 (1 ~ N)
  >       D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])
  > ```
  <img width="377" alt="스크린샷 2023-03-28 오전 7 23 54" src="https://user-images.githubusercontent.com/54930365/228080374-7b585f5d-0f9b-42bc-8a0b-5cacd7adc18d.png">

완성된 리스트는 모든 노드 간의 최단 거리를 알려준다.  
플로이드-워셜 아록리즘은 모든 노드 간의 최단 거리를 확인해 주기 때문에 시간 복잡도가 O(V^3)으로 빠르지 않은 편이다.  
이에 따라 플로이드-워셜 알고리즘을 사용해야 하는 문제가 나오면 일반적으로 노드 개수의 범위가 다른 그래프에 비해 적게 나타나는 것을 알 수 있다.  


<br><br>

## 08-7. 최소 신장 트리  
최소 신장 트리(Minimum Spanning Tree)란 그래프에서 모든 노드를 연결할 때 사용된 에지들의 가중치의 합을 최소로 하는 트리이다.  
최소 신장 트리의 대표적인 알고리즘으로 크루스칼, 프림 알고리즘이 있다. 오늘은 그 중에서 크루스칼 알고리즘에 대해 알아볼 것이다.  

- 최소 신장 트리의 특징  
  - 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 사이클을 포함하지 않는다.  
  - N개의 노드가 있으면 치소 신장 트리를 구성하는 에지의 개수는 항상 N - 1 개이다.  

- 최소 신장 트리의 핵심 이론  
1. 에지 리스트로 그래프를 구현하고 유니온 파인드 리스트 초기화하기  
  최소 신장 트리는 데이터를 노드가 아닌 에지 중심으로 저장하므로 인접 리스트가 아닌 에지 리스트의 형태로 저장한다.
  이 리스트는 일반적으로 노드 변수 2개와 가중치 변수로 구성된다.  
  사이클 처리를 위한 유니온 파인드 리스트도 함께 초기화한다. 리스트의 인덱스를 해당 자리의 값으로 초기화하면 된다.  
   <img width="337" alt="스크린샷 2023-03-28 오전 7 38 59" src="https://user-images.githubusercontent.com/54930365/228082657-b253d7dc-5729-4761-934e-712647417ce0.png">

2. 그래프를 가중치 기준으로 정렬하기  
  에지 리스트에 담긴 그래프 데이터를 가중치 기준으로 오름차순 정렬한다.  
   <img width="436" alt="스크린샷 2023-03-28 오전 7 41 10" src="https://user-images.githubusercontent.com/54930365/228083005-9e672417-3039-4020-8d54-4c4d16cbd798.png">

3. 가중치가 낮은 에지부터 연결 시도하기  
  가중치가 낮은 에지부터 순서대로 선택해 연결은 시도한다.  
  이때 바로 연결하지 않고 이 에지를 연결해을 때 그래프에서 사이클 형성 유무를 find 연산을 이용해 확인한 후 사이클이 형성되지 않을 때만 union 연산을 이용해 두 노드를 연결한다.  
   <img width="436" alt="스크린샷 2023-03-28 오전 7 43 09" src="https://user-images.githubusercontent.com/54930365/228083268-123b44c7-af67-4c9e-9891-a3f14c877497.png">

4. 과정 3 반복하기  
  전체 노드의 개수가 N개이면 연결한 에지의 개수가 N-1이 될 때까지 과정 3을 반복한다.  
   <img width="436" alt="스크린샷 2023-03-28 오전 7 44 54" src="https://user-images.githubusercontent.com/54930365/228083502-7cc9accc-7c4d-4152-9070-7a85d9515fc9.png">

5. 총 에지 비용 출력하기  
  에지의 개수가 N-1이 되면 알고리즘을 종료하고 완성된 최소 신장 트리의 총 에지 비용을 출력한다.


최소 신장 트리는 다른 그래프 알고리즘과는 달리, 에지 리스트의 형태를 이용해 데이터를 담는다는 특징이 있다.  
그 이유는 에지를 기준으로 하는 알고리즘이기 때문이다.   
또한 사이클이 존재하면 안 되는 특징을 지니고 있기 때문에 사이클 판별 알고리즘인 유니온 파인드 알고리즘을 내부에 구현해야 한다.  
