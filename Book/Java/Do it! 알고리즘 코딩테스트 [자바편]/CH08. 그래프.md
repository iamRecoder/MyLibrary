# CH08. 그래프
그래프는 노드와 에지로 구성된 집합이다.  
노드는 데이터를 표현하는 단위이고 에지는 노드를 연결한다. 9장에서 공부할 트리도 그래프의 일종이다.  
그래프는 여러 알고리즘에 많이 사용되는 자료구조이므로 코딩 테스트에 자주 등장한다.  

- 유니온 파인드: 그래프의 사이클이 생성되는지 판별하는 알고리즘
- 위상 정렬: 사이클이 없고 방향이 있는 그래프를 정렬. 정렬 결과가 한 개 이상이다. (ex. 수강신청)
- 다익스트라: 최단 거리 알고리즘. 간선의 가중치가 음수이면 안된다.
- 벨만-포드: 최단 거리 알고리즘. 간선의 가중치가 음수여도 된다.
- 플로이드-워셜: 최단 거리 알고리즘. 시작 노드가 정해져 있지 않다. 다익스트라, 벨만-포드에 비해 시간복잡도가 좋지 않다.
- 최소 신장 트리: MST. 최소 가중치를 갖는 트리. 유니온 파인드를 이용해서 사이클이 발생하는 지 확인한다.

<br><br>

## 08-1. 그래프의 표현
그래프를 구현하는 3가지 방법을 알아보자.  

1. 에지 리스트
   - 에지 리스트는 에지를 중심으로 그래프를 표현한다.  
   - 에지 리스트는 배열에 출발 노드, 도착 노드 또는 출발 노드, 도착 노드, 가중치를 저장하여 에지를 표현한다.

2. 인접 행렬
   - 인접 행렬은 2차원의 자료구조를 이용하여 그래프를 표현한다.
   - 인접 행렬은 에지 리스트와 다르게 노드 중심으로 그래프를 표현한다.  
   - 인접 행렬을 이용한 그래프 구현은 쉽다. 두 노드를 연결하는 에지의 여부와 가중치값은 배열에 직접 접근하면 바로 확인할 수 있다.
   - 그러나 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 비해 에지가 적을 때는 공간 효율성이 떨어진다.

3. 인접 리스트(제일 중요!!)
   - 인접 리스트는 ArrayList로 그래프를 표현한다.
   - 노드의 개수만큼 ArrayList를 선언한다. ex) ArrayList<Integer>[5]
   - 노드 별로 에지 개수가 일정하기 때문에 가변적인 ArrayList를 사용하면 공간 낭비를 줄일 수 있다.
   - 만약 가중치가 있는 경우라면 (도착 노드, 가중치)를 갖는 Node 클래스를 선언하여 ArrayList에 사용한 것이다.  ex) ArrayList<Node>[N]
   - 그래프 구현은 복잡한 편이지만 노드와 연결되어 있는 에지를 탐색하는 시간은 매우 뛰어나며, 노드 개수가 커도 공간 효율이 좋아 메모리 초과 에러도 발생하지 않는다.
   - 이런 장점으로 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호한다.  


<br><br>

## 08-2. 유니온 파인드
유니온 파인드는 일반적으로 여러 노드가 있을 떄 특정 2개의 노드를 연결해 1개의 잡합으로 묶는 union 연산과 두 노드가 같은 집합에 속해 있는지를 확인하는 find 연산으로 구성되어 있는 알고리즘이다.  

- 유니온 파인드의 핵심 이론
  - union 연산: 각 노드가 속한 집합을 1개로 합치는 연이다. 다른 집합에 속한 두 개의 노드를 하나의 집합으로 합친다.
  - find 연산: 특정 노드a에 대해 a가 속한 집합의 대표 노드를 반환하는 연산이다. 

- 유니온 파인드의 작동 원리
  유니온 파인드를 표현하는 일반적인 방법은 1차원 배열을 이용하는 것이다. 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다. 각 노드가 모두 대표 노드이므로 배열은 자신의 인덱스 값으로 초기화된다.
  2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 유니온 연산을 수행한다.
  - union 연산:
    find 연산을 수행 후, 두 노드의 루트 노드 값이 다르다면 union 연산을 수행한다.
  - find 연산: 
    1. 대상 노드 배열에 index 값과 value 값이 동일한지 확인한다.
    2. 동일하지 않으면 value 값이 가리키는 index 위치로 이동한다.
    3. 이동 위치의 index 값과 value 값이 같을 때까지 1,2번 단계를 반복한다. 반복이므로 이 부분은 재귀 함수로 구현한다.
    4. 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드값을 루트 노드값으로 변경한다.


<br><br>

## 08-3. 위상 정렬
위상 정렬은 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘이다.  

|기능|특징|시간 복잡도(노드 수: V, 에지 수: E)|
|:---|:---|:---|
|노드 간의 순서를 결정|사이클이 없어야 함|O(V + E)|

위상정렬에서는 항상 유일한 값으로 정렬되지 않는다. 또한 사이클이 존재하면 노드 간의 순서를 명확하게 정의할 수 없으므로 위상 정렬을 적용할 수 없다.  

- 위상 정렬의 핵심 이론
  1. 진입 차수를 이해해보자. 진입 차수는 자기 자신을 가리키는 에지의 개수이다.  
     <img width="394" alt="스크린샷 2023-03-25 오전 2 06 59" src="https://user-images.githubusercontent.com/54930365/227593409-bd85326e-498f-4ddd-8e0a-20851d7ce9e7.png">
  2. 진입 차수 배열에서 진입 차수가 0인 노드를 선택하고 선택된 노드를 정렬 배열에 저장한다. 그 후 인접 리스트에서 선택된 노드가 가리키는 노드들의 진입 차수를 1씩 뺀다.  
     <img width="379" alt="스크린샷 2023-03-25 오전 2 08 48" src="https://user-images.githubusercontent.com/54930365/227593796-181e3939-f8d8-4a6b-ab91-842d77467426.png">


<br><br>

## 08-4. 다익스트라


<br><br>

## 08-5. 벨만-포드


<br><br>

## 08-6. 플로이드-워셜


<br><br>

## 08-7. 최소 신장 트리  

