CH03. 연산자
===============
### 02. 연산자 종류
|   종류   |              연산자               |               설명                |
|:------:|:------------------------------:|:-------------------------------:|
| 산술 연산자 |        + - * / % << >>         |        사칙 연산과 나머지 연산(%)         |
| 비교 연산자 |        > < >= <= == !=         |        크고 작음과 같고 다름을 비교         |
| 논리 연산자 | && &#124;&#124; ! & &#124; ^ ~ |  '그리고(AND)'와 '또는(OR)'으로 조건을 연결  |                   
| 대입 연산자 |               =                |          우변의 값을 좌변에 저장          |
|   기타   |      (type) ?: instanceof      | 행변환 연산자, 삼항 연산자, instanceof 연산자 |
피연산자의 개수에 따라 `단항연산자`, `이항 연산자`, `삼항 연산자`로 분류된다.  
<br>

### 04. 연산자의 결합규칙
1. #### 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. #### 단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. #### 단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.  
<br>

### 07. 형변환 연산자
프로그램을 작성하다 보면 같은 타입뿐만 아니라 서로 다른 타입 간의 연산을 수행해야 하는 경우도 있다. 이럴 때는 연산을 수행하기 전에 타입을 일치시켜야 하는데, 변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 ```형변환(casting)```이라고 한다.
__형변환`(타입)피연산자`이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것__ 

형변환 방법은 아주 간단하다. 형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 된다.   
<br>

### 08. 자동 형변환  
서로 다른 타입 간의 대입이나 연산을 할 때, 먼저 형변환으로 타입을 일치시키는 것이 원칙이다. 하지만, 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다. 그렇다고 해서 형변환이 이루어지지 않는 것은 아니고, 컴파일러가 생략된 형변환을 자동적으로 추가해준다.  
그러나 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생략하면 에러가 발생한다.  
큰 타입에서 작은 타입으로 형변환을 하더라도 명시적으로 형변환을 해줬을 경우, 형변환이 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.  

__형변환을 하는 이유는 주로 서로 다른 두 타입을 일치시키기 위해서인데, 형변환을 생략하면 컴파일러가 알아서 자동적으로 형변환을 한다.__  
`기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환된다.`  
<br>

### 09. 사칙 연산자
피연산자가 정수형인 경우, 나누는 수로 0을 사용할 수 없다. 이 경우, 에러가 발생한다.  
__나누기 연산의 두 피연산자가 모두 int 타입인 경우, 연산결과 역시 int 타입이다. 이때 반올림이 발생하지 않는다는 점에 주의해야 한다.__
그래서 올바른 연산결과를 얻기 위해서는 두 피연산자 중 어느 한 쪽을 실수형으로 형변환해야 한다. 그래야만 다른 한 쪽도 같이 실수형으로 자동 형변환되어 결국 실수형의 값을 결과로 얻는다.  
<br>

### 10. 산술 변환
이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.  
이처럼 __연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것__ 을 `산술 변환` 또는 `일반 산술 변환`이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다.  

#### < 산술 변환 규칙 >
1. #### 두 피연산자의 타입을 같게 일치시킨다. (보다 큰 타입으로 일치)
    피연산자의 값손실을 최소화하기 위한 것이다.  
2. #### 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.  
    int보다 작은 타입(char, short 등)은 표현범위가 좁아서 연산 중에 오버플로우가 발생할 가능성이 높기 때문이다.  

__연산결과의 타입은 피연산자의 타입과 일치한다.__   
크기가 작은 자료형의 변수를 큰 자료형의 변수에 저장할 때는 자동으로 형변환(type conversion, casting)되지만, 반대로 큰 자료형의 값을 작은 자료형의 변수에 저장하려면 명시적으로 형변환 연산자를 사용해서 변환해줘야 한다.  
<br>

### 11. Math.round()로 반올림하기
반올림을 하려면 `Math.round()`를 사용하면 된다. 이 메서드는 소수점 첫째 자리에서 반올림한 결과를 정수로 반환한다. 만일 소수점 첫째 자리가 아닌 다른 자리에서 반올림을 하려면 10의 n제곱으로 적절히 곱하고 나누어야 한다.  
<br>

### 12. 나머지 연산자
나머지 연산자(%)는 나눗셈처럼 나누는 수로 0을 사용할 수 없고, 피연산자로 정수와 실수를 허용한다.  
나머지 연산자는 나누는 수로 음수도 허용한다. 그러나 부호는 무시되므로 결과는 음수의 절대값으로 나눈 나머지와 같다.  
<br>

### 13. 비교 연산자  
비교연산자 역시 이항 연산자이므로 비교하는 피연산자의 타입이 서로 다를 경우에는 자료형의 범위가 큰 쪽으로 자동 형변환하여 피연산자의 타입을 일치시킨 후에 비교한다는 점에 주의하자.  

- #### 대소비교 연산자 < > <= >=
    기본형 중에는 boolean을 제외한 나머지 자료형에 다 사용할 수 있지만 __참조형에는 사용할 수 없다.__  

- #### 등가비교 연산자 == !=
    위의 대소비교연산자와는 달리, 모든 자료형(기본형, 참조형)에 사용할 수 있다.  
    __기본형의 경우 변수에 저장되어 있는 `값이 같은지`를 알 수 있고, 참조형의 경우 객체의 주소값을 저장하기 때문에 두 개의 피연산자(참조변수)가 같은 객체를 가리키고 있는지(`주소값이 같은지`)를 알 수 있다.__    
    기본형과 참조형은 서로 형변환이 가능하지 않기 때문에 등가비교 연산자(==, !=)로 기본형과 참조형을 비교할 수는 없다.  
<br>

### 14. 문자열 비교
두 문자열을 비교할 때는, 비교 연산자 '==' 대신 `equals()`라는 메서드를 사용해야 한다.  
비교 연산자는 두 문자열이 완전히 같은 것인지 비교할 뿐이므로, 문자열의 내용이 같은지 비교하기 위해서는 equals()를 사용하는 것이다.  
만일 대소문자를 구별하지 않고 비교하고 싶으면 `equalsIgnoreCase()`를 사용하면 된다.  
<br>

### 15. 논리 연산자 && ||
논리 연산자는 둘 이상의 조건을 '그리고(AND)'나 '또는(OR)'으로 연결하여 하나의 식으로 표현할 수 있게 해준다.   
<br>

### 16. 논리 부정 연산자 !
논리 부정 연산자는 true와 false를 반대로 바꾼다.  
논리 부정 연산자는 단항 연산자이기 때문에 결합 방향이 오른쪽에서 왼쪽으로 피연산자와 가까운 것부터 먼저 연산된다.  
<br>

### 17. 조건 연산자
조건 연산자`조건식? 식1 : 식2`는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며, 삼항 연산자는 조건 연산자 하나뿐이다.  
__조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술 변환이 발생한다.__    
<br>

### 18. 대입 연산자
대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 저장하는데 사용된다.  
대입 연산자는 연신자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행되고 연산 진행 방향이 오른쪽에서 왼쪽이다.  

__대입 연산자의 오른쪽 피연산자는 변수뿐만 아니라 식이나 상수 등 모두 가능한 반면, 왼쪽 피연산자는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다.__    
<br>

### 19. 복합 대입 연산자   
대입 연산자는 다른 연산자(op)와 결합하여 `op=`와 같은 방식으로 사용될 수 있다. 결합된 두 연산자는 반드시 공백없이 붙여 써야 한다.  
