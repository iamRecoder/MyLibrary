CH08. 예외처리
============
### 01. 프로그램 오류  
```markdown
컴파일 에러   컴파일 시에 발생하는 에러
런타임 에러   실행 시에 발생하는 에러
논리적 에러   실행은 되지만, 의도와는 다르게 동작하는 것
```
발생 시점에 따라 `컴파일 에러`와 `런타임 에러`로 나눌 수 있고, 이 외에도 컴파일도 잘되고 실행도 잘되지만 의도한 것과 다르게 동작하는 `논리적 에러`가 있다.  
<br>

```
에러(error)     프로그램 코드에 의해서 수습될 수 없는 심각한 오류
예외(exception) 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
```
에러는 메모리 부족이나 스택오버플로우와 같이 일단 발생하면 복구할 수 없는 심각한 오류이고, 예외는 발생하더라도 수습될 수 있는 비교적 덜 심각한 것이다.  
<br>

### 02. 예외 클래스의 계층구조  
자바에서는 실행 시 발생할 수 있는 오류(Exception과 Error)를 클래스로 정의하였다.   
예외 클래스들을 다음과 같이 두 그룹으로 나눠질 수 있다.  
1. Exception 클래스와 그 자손들(RuntimeException과 자손들 제외)
2. RuntimeException 클래스와 그 자손들
<br>

### 03. Exception과 RuntimeException  
```markdown
Exception 클래스들         사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
RuntimeException 클래스들  프로그래머의 실수로 발생하는 예외
```
__Exception 클래스들은 주로 외부의 영향으로 발생할 수 있는 것들로서, 프로그램의 사용자들의 동작에 의해서 발생하는 경우가 많다.__  
ex) `존재하지 않는 파일의 이름을 입력(FileNotFoundException)`, `실수로 클래스의 이름을 잘못 적음(ClassNotFoundException)`, `입력한 데이터 형식이 잘못됨(DataFormatException)`   
<br>

__RuntimeException 클래스들은 주로 프로그래머의 실수에 의해서 발생될 수 있는 예외들로 자바의 프로그래밍 요소들과 관계가 깊다.__  
ex) `배열의 범위를 벗어나는 경우(ArrayIndexOutOfBoundsException)`, `값이 null인 참조변수의 멤버를 호출하려 하는 경우(NullPointerException)`, `클래스 간의 형변환을 잘못하는 경우(ClassCastException)`, `정수를 0으로 나누는 경우(ArithmeticException)`   
<br>

### 04. 예외 처리하기 - try - catch 문
프로그램의 실행도중에 발생하는 에러는 어쩔 수 없지만, 예외는 프로그래머가 이에 대한 처리를 미리 해주어야 한다.  
예외처리(exception handling)이란, `프로그램 실행 시 발생할 수 있는 예기치 못한 예외의 발생에 대비한 코드를 작성하는 것(정의)`이며, 예외처리의 목적은 `예외의 발생으로 인한 실행 중인 프로그램의 갑작스런 비정상 종료를 막고, 정상적인 실행상태를 유지할 수 있도록 하는 것(목적)`이다.  

발생한 예외를 처리하지 못하면, 프로그램은 비정상적으로 종료되며, 처리되지 못한 예외(uncaught exception)는 JVM의 '예외처리기(UncaughtExceptionHandler)'가 받아서 예외의 원인을 화면에 출력한다.  

예외를 처리하기 위해서는 try-catch 문을 사용하며, 그 구조는 다음과 같다.  
```java
// * try-catch 블럭 내에 포함된 문장이 하나뿐이어도 괄호{}를 생략할 수 없다.
try{
    // 예외가 발생할 가능성이 있는 문장들을 넣는다.
        } catch (Exception1 e1){
    // Exception1이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
        } catch (ExceptionN eN){
    // ExceptionN이 발생했을 경우, 이를 처리하기 위한 문장을 적는다.
        }
```
하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블럭이 올 수 있으며, 이 중 발생한 예외의 종류와 일치하는 단 한 개의 catch 블럭만 수행된다. 
발생한 예외의 종류와 일치하는 catch 블럭이 없으면 예외는 처리되지 않는다.  
<br>

### 06. 예외의 발생과 catch 블럭  
__예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어 진다.__  
첫번째 catch 블럭부터 차례로 내려가면서 catch 블럭의 괄호() 내에 선언된 참조변수의 종류와 생성된 예외클래스의 인스턴스에 `instanceof` 연산자를 이용해서 검사하게 되는데, 검사결과가 true인 catch 블럭을 만날 때까지 검사는 계속된다.   
검사결과가 true인 catch 블럭을 찾게 되면 블럭에 있는 문장들을 모두 수행한 후에 try-catch 문을 빠져나가고 예외는 처리되지만, 검사결과가 true인 catch 블럭이 하나도 없으면 예외는 처리되지 않는다.  

모든 예외 클래스는 Exception 클래스의 자손이므로, catch 블럭의 괄호()에 Exception 클래스 타입의 참조변수를 선언해 놓으면 어떤 종류의 예외가 발생하더라도 이 catch 블럭에 의해서 처리된다.  
<br>

### 07. printStackTrace()와 getMessage()
예외가 발생했을 때 생성되는 예외 클래스의 인스턴스에는 발생한 예외에 대한 정보가 담겨 있으며, `getMessage()`와 `printStackTrace()`를 통해서 이 정보들을 얻을 수 있다.   
```java
printStackTrace()   예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력한다.
getMessage()        발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있다.
```
<br>

### 08. 멀티 catch 블럭
JDK 1.7부터 여러 catch블럭을 `|` 기호를 이용해서, 하나의 catch 블럭으로 합칠 수 있게 되었으며, 이를 `멀티 catch 블럭`이라 한다. 
__'멀티 catch 블럭'을 이용하면 중복되 코드를 줄일 수 있다. 그리고 '|' 기호로 연결할 수 있는 예외 클래스의 개수에는 제한이 없다.__  
만일 멀티 catch 블럭의 '|' 기호로 연결된 예외 클래스가 조상과 자손 관계에 있다면 컴파일 에러가 발생한다. 이는 그냥 조상 클래스만 써주는 것과 똑같기 때문에 불필요한 코드는 제거하라는 뜻에서 에러가 발생하는 것이다.  
<br>

### 09. 예외 발생시키기  
키워드 `throw`를 사용해서 프로그래머가 고의로 예외를 발생시킬 수 있으며, 방법은 아래의 순서를 따르면 된다.  
1. 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음   
`Exception e = new Exception("고의로 발생시켰음");`
2. 키워드 throw를 이용해서 예외를 발생시킨다.   
`throw e;`
<br>

### 10. checked 예외, unchecked 예외
`Exception 클래스와 그 자손들(checked 예외)`이 발생할 가능성이 있는 문장들에 대해 예외처리를 해주지 않으면 컴파일조차 되지 않는다.  

`RuntimeException 클래스와 그 자손(unchecked 예외)`에 해당하는 예외는 프로그래머가 실수로 발생하는 것들이기 때문에 예외처리를 강제하지 않는 것이다.  
<br>

### 11. 메서드에 예외 선언하기  
예외를 처리하는 방법에는 지금까지 배워 온 try-catch문을 사용하는 것 외에, 예외를 메서드에 선언하는 방법이 있다.  
메서드에 예외를 선언하여면, 메서드의 선언부에 키워드 `throws`를 사용해서 메서드 내에서 발생할 수 있는 예외를 적어주기만 하면 된다. 그리고 예외가 여러 개일 경우에는 쉼표(,)로 구분한다.  
```java
void method() throws Exception1, Exception2, ... ExceptionN {
    // 메서드 내용
        }
```
메서드의 선언부에 예외를 선언함으로써 메서드를 사용하려는 사람이 메서드의 선언부를 보았을 때, 이 메서드를 사용하기 위해서는 어떠한 예외들이 처리되어져야 하는지 쉽게 알 수 있다.  
이때, 예외를 발생시키는 키워드 throw와 예외를 메서드에 선언할 때 쓰이는 throws를 헷갈리지 않도록 주의하자.  
<br>

### 12. 메서드에 예외 선언하기 예제1  
예외가 발생한 메서드에서 예외처리를 하지 않고 자신을 호출한 메서드에게 예외를 넘겨줄 수는 있지만, 이것으로 예외가 처리된 것은 아니고 예외를 단순히 전달만 하는 것이다. 
결국 어느 한 곳에서는 반드시 try-catch 문으로 예외처리를 해주어야 한다.   
<br>

### 13. 메서드에 예외 선언하기 예제2
예외가 발생했을 때, 예외가 발생한 메서드 내에서 자체적으로 처리해도 되는 경우 메서드 내에 try-catch 문을 넣어서 처리하고, 위 예제처럼 메서드 내에서 자체적으로 해결이 안 되는 경우(파일 이름을 다시 받아와야 하는 경우)에는 예외를 선언해서, 호출한 메서드가 처리하도록 해야 한다.  
<br>

### 14. finally 블럭
__finally 블럭은 예외의 발생여부에 상관없이 실행되어야 할 코드를 포함시킬 목적으로 사용된다.__ 
try-catch문의 끝에 선택적으로 덧붙여 사용할 수 있으며, try-catch-finally의 순서로 구성된다.
```java
try{
    // 예외가 발생할 가능성이 있는 문장들을 넣는다.
        } catch (Exception1 e1) {
    // 예외 처리를 위한 문장을 적는다.
        } finally {
    // 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣는다.
    // finally 블럭은 try-catch 문의 맨 마지막에 위치해야한다.    
        }
```
<br>

### 15. 사용자 정의 예외 만들기
기존의 정의된 예외 클래스 외에 필요에 따라 프로그래머가 새로운 에외 클래스를 정의하여 사용할 수 있다. 
보통 Exception 클래스 또는 RuntimeException 클래스로부터 상속받는 클래스를 만들지만, 필요에 따라서 알맞은 예외 클래스를 선택할 수 있다.  

기존의 예외 클래스는 주로 Exception을 상속받아서 'checked 예외'로 작성하는 경우가 많았지만, 요즘은 예외처리를 선택적으로 할 수 있도록 RuntimeException을 상속받아서 작성하는 쪽으로 바뀌어가고 있다. 
'checked 예외'는 반드시 예외처리를 해주어야 하기 때문에 예외처리가 불필요한 경우에도 try-catch 문을 넣어서 코드가 복잡해지기 때문이다.  
<br>

### 17. 예외 되던지기(exception re-throwing)  
한 메서드에서 발생할 수 있는 예외가 여럿인 경우, 몇 개는 try-catch 문을 통해서 메서드 내에서 자체적으로 처리하고, 그 나머지는 선언부에 지정하여 호출한 메서드에서 처리하도록 함으로써, 양쪽에서 나눠서 처리되도록 할 수 있다.  
그리고 심지어는 단 하나의 예외에 대해서도 예외가 발생한 메서드와 호출한 메서드, 양쪽에서 처리하도록 할 수 있다.  
이것은 예외를 처리한 후에 인위적으로 다시 발생시키는 방법을 통해서 가능한데, 이것을 `예외 되던지기(exception re-throwing)`라고 한다.  

먼저 예외가 발생할 가능성이 있는 메서드에서 try-catch 문을 사용해서 예외를 처리해주고 catch 문에서 필요한 작업을 행한 후에 throw 문을 사용해서 예외를 다시 발생시킨다. 
다시 발생한 예외는 이 메서드를 호출한 메서드에게 전달되고 호출한 메서드의 try-catch문에서 예외를 또다시 처리한다.  
이 방법은 하나의 예외에 대해서 예외가 발생한 메서드와 이를 호출한 메서드 양쪽 모두에서 처리해줘야 할 작업이 있을 때 사용된다. 
이 때 주의할 점은 예외가 발생할 메서드에서는 try-catch 문을 사용해서 예외처리를 해줌과 동시에 메서드의 선언부에 발생할 예외를 throws에 지정해줘야 한다는 것이다.  
<br>

### 18. 연결된 예외(chained exception)
한 예외가 다른 예외를 발생시킬 수도 있다.  
A 예외를 먼저 생성한 후에, initCause()로 B 예외를 A 예외의 원인 예외로 등록한다. 그리고 throw로 이 예외를 던진다. 
initCause()는 Exception 클래스의 조상인 Throwable 클래스에 정의되어 있기 떄문에 모든 예외에서 사용 가능하다.  
```java
Throwable initCause(Throwable cause)    지정한 예외를 원인 예외로 등록
Throwable getCause()                    원인 예외를 반환
```
발생한 예외를 그냥 처리하지 않고 원인 예외로 등록해서 다시 예외를 발생시킼는 이유는 여러가지 예외를 하나의 큰 분류의 예외로 묶어서 다루기 위해서이다.  
예외가 원인 예외를 포함할 수 있게 하면, 두 예외는 상속관계가 아니어도 상관없다. 
또 다른 이유는 checked 예외를 unchecked 예외로 바꿀 수 있도록 하기 위해서이다. 
checked 예외가 발생해도 예외를 처리할 수 없는 상황이 발생하기 시작했고 checked 예외를 unchecked 예외로 바꾸면 예외처리가 선택적이 되므로 억지로 예외처리를 하지 않아도 된다.   




