CH12. 지네릭스, 열거형, 애너테이션  
=========================
### 01. 지네릭스(Generics)  
__지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 `컴파일 시의 타입 체크(compile-time type check)`를 해주는 기능이다.__ 
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.  
저장할 객체의 타입을 지정해주면, 지정한 타입 외에 다른 타입의 객체가 저장되면 에러가 발생한다. 
그리고 저장된 객체를 꺼낼 때는 형변환할 필요가 없어서 편리하다.  
```markdown
지네릭스의 장점
1. 타입 안정성을 제공한다.  
2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
```
<br>

### 02. 타입 변수  
ArrayList 클래스의 선언에서 클래스 이름 옆의 `<>` 안에 있는 E를 `타입 변수(type variable)`라고 하며, 일반적으로 'Type'의 첫 글자를 따서 T를 사용한다. 
그렇다고 타입 변수로 반드시 T를 사용해야 하는 것은 아니며, T가 아닌 다른 것을 사용해도 된다. 
주로 ArrayList<E>와 Map(K,V)처럼 첫 글자를 따서 타입 변수의 이름으로 사용한다. 

__기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴 타입으로 Object 타입의 참조변수를 많이 사용했고, 그로 인해 형변환이 불가피했지만, 
이젠 Object 타입 대신 원하는 타입을 지정하기만 하면 되는 것이다.__    
<br>

### 03. 타입 변수에 대입하기   
ArrayList와 같은 지네릭 클래스를 생성할 때는 다음과 같이 참조변수와 생성자에 타입 변수 E 대신에 Tv와 같은 실제 타입을 지정해주어야 한다.  
```java
// 타입 변수 E 대신에 실제 타입 Tv를 대입  
ArrayList<Tv> tvList = new ArrayList<Tv>();
```
이때, 타입 변수 E대신 지정된 타입 Tv를 `대입된 타입(parameterized type)`이라고 한다. 
타입이 대입되고 나면 ArrayList의 선언에 포함된 타입 변수 E가 아래와 같이 지정된 타입으로 바뀐다고 생각하면 된다. 
타입이 대입되어 ArrayList의 get() 메서드가 Object가 아닌 Tv를 반환하게 되므로 형변환이 필요없게 되는 것이다.   
<br>

### 04. 지네릭스 용어  
```java
class Box<T> {}
```
```markdown
Box<T>   지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.
T        타입 변수 또는 타입 매개변수. 
Box      원시 타입
```
타입 매개변수에 타입을 지정하는 것을 `제네릭 타입 호출`이라고 하고, 지정된 타입 'String'을 `매개변수화된 타입` 또는 `대입된 타입`이라고 한다.  

Box< String>과 Box< Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 
이 둘이 별개의 클래스를 의미하는 것은 아니다.  
컴파일 후에 Box<String>과 Box<Integer>는 이들의 '원시 타입'인 Box로 바뀐다. 즉, 지네릭 타입이 제거된다.  
<br>

### 05. 지네릭 타입과 다형성  
__지네릭 클래스의 객체를 생성할 때, 참조변수에 지정해준 지네릭 타입과 생성자에 지정해준 지네릭 타입은 일치해야 한다.__ 서로 상속관계에 있는 클래스이더라도 일치해야 한다.  
그러나 지네릭 타입이 아닌 클래스의 타입 간에 다형성을 적용하는 것은 가능하다. 이 경우에도 지네릭 타입은 일치해야 한다.  
```java
ArrayList<Tv> list = new ArrayList<Tv>();       // OK. 지네릭 타입 일치
ArrayList<Product> list = new ArrayList<Tv>();  // 에러. 지네릭 타입 불일치

List<Tv> list = new ArrayList<Tv>();            // OK. 다형성. ArrayList가 List를 구현  
List<Tv> list = new LinkedList<Tv>();           // OK. 다형성. LinkedList가 List를 구현  
```
<br>

### 07. Iterator<E>  
컬렉션 클래스뿐만 아니라 Iterator에도 제네릭스가 적용되어 있다.  
```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    void remove();
}
```
<br>

### 09. 제한된 지네릭 클래스  
__지네릭 타입에 `extends`를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.__  
```java
class FruitBox<T extends Fruit> {   // Fruit의 자손만 타입으로 지정가능  
    ArrayList<T> list = new ArrayList<T>();
}
```
여전히 한 종류의 타입만 담을 수 있지만, Fruit 클래스의 자손들만 담을 수 있다는 제한이 더 추가된 것이다. 
만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이때도 `extends`를 사용한다. `implements`를 사용하지 않는다는 점에 주의하자.  
<br>  

### 11. 제네릭스의 제약  
객체별로 다른 타입을 지정하는 것은 적절하다. 
지네릭스는 이처럼 인스턴스별로 다르게 동작하도록 만든 기능이다.  
__그러나 모든 객체에 대해 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없다.__ 
T는 인스턴스 변수로 간주되기 때문이다.  
```java
class Box<T> {
    static T item;  // 에러  
    static int compare(T t1, T t2) {...}    // 에러  
}
```
<br>  

__그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다.__ 
지네릭 타입의 참조변수를 선언하는 것은 가능하지만, 'new T[10]'과 같이 배열을 생성하는 것은 안된다는 뜻이다.  

```java
class Box<T> {
    T[] itemArr;    // OK. T 타입의 배열을 위한 참조변수 
    ...
    T[] tmpArr = new T[itemArr.length]; // 에러. 지네릭 배열 생성불가!
}
```
지네릭 배열을 생성할 수 없는 이유는 new 연산자 때문인데, 
이 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다. 
그런데 위의 코드에 정의된 Box<T> 클래스를 컴파일하는 시점에서는 T가 어떤 타입이 될지 전혀 알 수 없다. `instanceof` 연산자도 new 연산자와 같은 이유로 T를 피연산자로 사용할 수 없다.  
<br>  

### 12. 와일드 카드  
지네릭 클래스를 생성할 때, 참조변수에 지정된 지네릭 타입과 생성자에 지정된 지네릭 타입은 일치해야 한다.   
그러면 지네릭 타입에 다형성을 적용할 방법은 없을까? __지네릭 타입으로 `와일드 카드`사용하여 다형성을 적용할 수 있다.__ 
와일드 카드는 `기호 ?`를 사용하는데 다음과 같이 'extends'와 'super'로 상한과 하한을 제한할 수 있다.  
```markdown
<? extends T>   와일드 카드의 상한 제한. T와 그 자손들만 가능
<? super T>     와일드 카드의 하한 제한. T와 그 조상들만 가능
<?>             제한없음. 모든 타입이 가능. <? extends Object>와 동일  
```
와일드 카드를 이용하면 다음과 같이 하나의 참조변수로 다른 지네릭 타입이 지정된 객체를 다룰 수 있다.  
```java
// 제네릭 타입이 '? extends Product'이면, Product와 Product의 모든 자손이 OK
ArrayList<? extends Product> list = new ArrayList<Tv>();    // OK
ArrayList<? extends Product> list = new ArrayList<Audio>(); // OK  
```
와일드 카드를 메서드의 매개변수에 적용하면, 지네릭 타입이 다른 여러 객체를 매개변수로 지정할 수 있다.  
<br>

### 14. 지네릭 메서드  
__메서드 선언부에 지네릭 타입이 선언된 메서드를 `지네릭 메서드`라 한다.__ 
지네릭 타입의 선언 위치는 반환 타입 바로 앞이다.  
```java
class FruitBax<T> {
        ...
    static <T> void sort(List<T> list, Comparator<? super T> c) {
        ...
    }
}
```
위의 코드에서 지네릭 클래스 FruitBox에 선언된 타입 매개변수 T와 지네릭 메서드 sort()에 선언된 타입 매개변수 T는 타입 문자만 같을 뿐 서로 다른 것이다. 
그리고 sort()가 static 메서드라는 점에 주목하자.  
__앞서 설명한 것처럼, static 멤버에는 타입 매개변수를 사용할 수 없지만, 이처럼 메서드에는 지네릭 타입을 선언하고 사용하는 것은 가능하다.__  

메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 이해하기 쉬운데, 
이 타입 매개변수는 __메서드 내에서만 지역적으로 사용될 것이므로__ 메서드가 static이건 아니건 상관없다.  

지네릭 메서드를 호출할 때는 아래와 같이 타입 변수에 타입을 대입해야 한다. 그러나 대부분의 경우 컴파일러가 대입된 타입을 추정할 수 있기 때문에 생략해도 된다. 
아래 코드에서도 fruitBox와 appleBox의 선언부를 통해 컴파일러가 대입된 타입을 추정할 수 있다.  
```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
FruitBox<Apple> appleBox = new FruitBox<Apple>();
        ...
System.out.println(Juicer.<Fruit>makeJuice(fruitBox));
System.out.println(Juicer.<Apple>makeJuice(appleBox));
System.out.println(Juicer.makeJuice(fruitBox));     // 타입 변수에 타입을 대입하지 않아도 컴파일러가 변수 선언부를 통해 대입된 타입을 추정 가능. 
System.out.println(Juicer.makeJuice(appleBox));     // 타입 변수에 타입을 대입하지 않아도 컴파일러가 변수 선언부를 통해 대입된 타입을 추정 가능.
```
__한 가지 주의할 점은 지네릭 메서드를 호출할 때, 대입된 타입을 생략할 수 없는 경우에는 참조변수나 클래스 이름을 생략할 수 없다는 것이다.__  
```java
System.out.println(<Fruit>makeJuice(fruitBox));         // 에러. 클래스 이름 생략 불가.
System.out.println(this.<Fruit>makeJuice(fruitBox));    // OK
System.out.println(Juicer.<Fruit>makeJuice(fruitBox));  // OK
```
<br>  

### 15. 지네릭 타입의 형변환  
__지네릭 타입과 원시 타입 간의 형변환은 항상 가능하다.__ 다만 경고가 발생할 뿐이다.  
__대입된 타입과 다른 지네릭 타입 간의 형변환은 불가능하다.__  
```java
Box box = null;
Box<Object> objBox = null;
Box<String> strBox = null;

// 지네릭 타입과 원시 타입 간의 형변환 가능
box = (Box)objBox;          // OK. 지네릭 타입 -> 원시 타입. 경고 발생
objBox = (Box<Object>)box;  // OK. 원시 타입 -> 지네릭 타입. 경고 발생

// 다른 지네릭 타입 간에는 형변환 불가능
objBox = (Box<Object>)strBox;   // 에러. Box<String> -> Box<Object>
strBox = (Box<String>)objBox;   // 에러. Box<Object> -> Box<String>

// 지네릭 타입의 다형성. 와일드 카드를 사용
// 매개변수로 FruitBox<Fruit>, FruitBox<Apple>, FruitBox<Grape> 등이 가능
static Juice makeJuice(FruitBox<? extends Fruit> box) { ... }
```
<br>  

### 16. 지네릭 타입의 제거  
컴파일러는 지네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에 형변환을 넣어준다. 
그리고 지네릭 타입을 제거한다.   
__즉, 컴파일된 파일(*.class)에는 지네릭 타입에 대한 정보가 없는 것이다.__  
이렇게 하는 주된 이유는 지네릭이 도입되기 이전(JDK 1.5 이전)의 소스 코드와의 호환성을 유지하기 위해서이다.  

지네릭 타입의 기본적인 제거 과정은 다음과 같다.  
1. 지네릭 타입의 경계를 제거한다.  
지네릭 타입으로 치환되고 클래스 옆의 지네릭 타입 선언이 제거된다.  
2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가한다.  
<br>

### 17. 열거형(enum)  
__열거형은 여러 상수를 선언해야 할 때, 편리하게 선언할 수 있는 방법이다.__ 
열거형을 이용하면 다음과 같이 간단히 상수를 선언할 수 있다.  
열거형을 이용해서 상수를 정의한 경우는 값을 비교하기 전에 타입을 먼저 비교하므로 값이 같더라도 타입이 다르면 컴파일 에러가 발생한다.  
<br>

### 18. 열거형의 정의와 사용  
열거형을 정의하는 방법은 간단하다. 
다음과 같이 괄호{} 안에 상수의 이름을 나열하기만 하면 된다.  
```java
enum 열거형이름 { 상수명1, 상수명2, ... }
```
열거형에 정의된 상수를 사용하는 방법은 `열거형 이름.상수명`이다. 
클래스의 static 변수를 참조하는 것과 동일하다.  

열거형 상수간의 비교에는 '=='를 사용할 수 있다. 
그러나 '<', '>' 와 같은 비교연산자는 사용할 수 없고 `compareTo()`는 사용가능하다.  
<br>

### 19. 열거형의 조상 - java.lang.Enum  
모든 열거형의 조상은 `java.lang.Enum`이며, 이 클래스는 다음과 같은 메서드를 제공한다.  

|메서드| 설명                                 |
|:---:|:-----------------------------------|
|Class<E> getDeclaringClass()| 열거형의 Class 객체를 반환한다.               |
|String name() | 열거형 상수의 이름을 문자열로 반환한다.             |
|int ordinal()| 열거형 상수가 정의된 순서를 반환한다.(0부터 시작)      |
|T valueOf(Class<T> enumType, String name)| 지정된 열거형에서 name과 일치하는 열거형 상수를 반환한다. |  
<br>

### 21. 열거형에 멤버 추가하기  
Enum 클래스에 정의된 `ordinal()`이 열거형 상수가 정의된 순서를 반환하지만, 이 값을 열거형 상수의 값으로 사용하지 않는 것이 좋다. 
이 값은 내부적인 용도로만 사용되기 위한 것이기 때문이다.  
__열거형 상수의 값이 불규칙적인 경우에는 다음과 같이 열거형 상수의 이름 옆에 원하는 값을 괄호()와 함께 적어주면 된다.__  
그리고 지정된 값을 저장할 수 있는 인스턴스 변수와 생성자를 새로 추가해 주어야 한다. 
주의할 점은, 먼저 열거형 상수를 모두 정의한 다음에 다른 멤버들을 추가해야 한다는 것이다.  
```java
enum Direction { 
    EAST(1), SOUTH(5), WEST(-1), NORTH(10);     // 끝에 ';'를 추가햐야 한다.  
    
    private final int value;    // 정수를 저장할 필드(인스턴스 변수)를 추가 
    Direction(int value){ this.value = value; } // 생성자를 추가  
    
    public int getValue() { return value; }     // 외부에서 인스턴스 변수 값을 얻을 수 있도록 추가
}
```

열거형 Direction에 새로운 생성자가 추가되었지만 일반 객체와 같이 열거형 객체를 생성할 수 없다. 
__열거형 생성자는 제어자가 묵시적으로 private이기 때문이다.__  
<br>

### 23. 애너테이션이란?  
프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 `애너테이션`이다. 
__애너테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.__   

JDK에서 제공하는 __표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공__ 한다. 
그리고 __새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션__ 도 제공한다.  
<br>  

### 24. 표준 애너테이션  
자바에서 기본적으로 제공하는 애너테이션은 몇 개 없다. 
그나마 이들의 일부는 `메타 애너테이션`으로 애너테이션을 정의하는데 사용되는 애너테이션의 애너테이션이다.  

다음은 자바에서 기본적으로 제공하는 __표준 애너테이션__ 이다.  

|        애너테이션         |설명|
|:--------------------:|:---|
|      @Override       |컴파일러에게 메서드를 오버라이딩하는 것이라고 알린다.|
|     @Deprecated      |앞으로 사용하지 않을 것을 권장하는 대상에 붙인다.|
|  @SuppressWarnings   |컴파일러의 특정 경고메시지가 나타나지 않게 해준다.|
|     @SafeVarargs     |지네릭스 타입의 가변인자에 사용한다.(JDK1.7)|
| @FunctionalInterface |함수형 인터페이스라는 것을 알린다.(JDK1.8)|
|       @Native        |native 메서드에서 참조되는 상수 앞에 붙인다.|


<br>  

다음은 자바에서 기본적으로 제공하는 __메타 애너테이션__ 이다.  

|애너테이션| 설명                                   |
|:---:|:-------------------------------------|
|@Target| 애너테이션이 적용가능한 대상을 지정하는데 사용한다.         |
|@Documented| 애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다. |
|@Inherited| 애너테이션이 자손 클래스에 상속되도록 한다.             |
|@Retention| 애너테이션이 유지되는 범위를 지정하는데 사용한다.          |
|@Repeatable| 애너테이션을 반복해서 적용할 수 있게 한다.(JDK1.8)     |
<br>

### 25. @Override  
메서드 앞에만 붙일 수 있는 애너테이션으로, __조상의 메서드를 오버라이딩하는 것이라는 걸 컴파일러에게 알려주는 역할을 한다.__  
메서드 앞에 `@Override`를 붙이면, 컴파일러가 같은 이름의 메서드가 조상에 있는지 확인하고 없으면, 에러 메시지를 출력한다.  
이처럼 오버라이딩할 때 메서드 앞에 `@Override`를 붙이는 것은 필수는 아니지만, 알아내기 어려운 실수를 미연에 방지해주므로 반드시 붙이도록 하자.  
<br>  

### 26. @Deprecated  
__`@Deprecaated` 애너테이션이 붙은 대상은 다른 것으로 대체되었으니 더 이상 사용하지 않을 것을 권한다는 의미이다.__  
만일 `@Deprecated`가 붙은 대상을 사용하는 코드를 작성하면, 컴파일할 때 아래와 경고 메시지가 나타난다.  
<br>

### 27. @FunctionalInterface  
__'함수형 인터페이스'를 선언할 때, 이 애너테이션을 붙이면 컴파일러가 '함수형 인터페이스'를 올바르게 선언했는지 확인하고, 잘못된 경우 에러를 발생시킨다.__  
필수는 아니지만 붙이면 실수를 방지할 수 있으므로 '함수형 인터페이스'를 선언할 때는 이 애너테이션을 반드시 붙이도록 하자.  
함수형 인터페이스는 추상 메서드가 하나뿐인 인터페이스를 의미한다.  
<br>

### 28. @SuppressWarnings  
__컴파일러가 보여주는 경고 메시지가 나타나지 않게 억제해준다.__  
묵인해야 하는 경고가 발생하는 대상에 `@SuppressWarning`을 붙여서 컴파일 후에 어떤 경고 메시지도 나타나지 않게 할 수 있다.  
`@SuppressWarnings`로 억제할 수 있는 경고 메시지의 종류는 여러 가지가 있는데, JDK의 버전이 올라가면서 계속 추가될 것이다. 
이중에서 주로 사용되는 것은 `deprecation`, `unchecked`, `rawtypes`,`varargs` 정도이다.  

`deprecation`은 '@Deprecated'가 붙은 대상을 사용해서 발생하는 경고를 억제할 때 사용한다.    
`unchecked`는 지네릭스로 타입을 지정하지 않았을 때 발생하는 경고를 억제할 때 사용한다.  
`rawtypes`는 지네릭스를 사용하지 않아서 발생하는 경고를 억제할 때 사용한다.  
`varargs`는 가변인자의 타입이 지네릭 타입일 때 발생하는 경고를 억제할 때 사용한다.  
```java
@SuppressWarnings({"deprecation", "unchecked", "varargs"})
```
<br>  

### 29. 메타 애너테이션  
앞에서 설명한 것과 같이 메타 애너테이션은 __애너테이션을 위한 애너테이션__, 즉 __애너테이션에 붙이는 애너테이션__ 으로 애너테이션을 정의할 때 애너테이션의 적용대상이나 유지기간 등을 지정하는데 사용된다.  
<br>  

### 30. @Target  
__애너테이션이 적용가능한 대상을 지정하는데 사용된다.__  
아래는 '@SuppressWarnings'를 정의한 것으로, 이 애너테이션에 적용할 수 있는 대상을 '@Target'으로 지정하였다.  
```java
@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```
'@Target'으로 지정할 수 있는 애너테이션 적용대상의 종류는 아래와 같다.  

|대상 타입| 의미                  |
|:---|:--------------------|
|ANNOTATION_TYPE| 애너테이션               |
|CONSTRUCTOR| 생성자                 |
|FIELD| 필드(멤버변수, enum 상수)   |
|LOCAL_VARIABLE| 지역변수                |
|METHOD| 메서드                 |
|PACKAGE| 패키지                 |
|PARAMETER| 매개변수                |
|TYPE| 타입(클래스, 인터페이스, enum) |
|TYPE_PARAMETER| 타입 매개변수(JDK1.8)     |
|TYPE_USE| 타입이 사용되는 모든 곳(JDK1.8)       |
<br>

### 31. @Retention  
__애너테이션이 유지되는 기간을 지정하는데 사용된다.__  
애너테이션의 유지 정책의 종류는 다음과 같다.  

|유지 정책|의미|
|:---|:---|
|SOURCE|소스 파일에만 존재. 클래스 파일에는 존재하지 않음.|
|CLASS|클래스 파일에 존재. 실행시에 사용불가. 기본값|
|RUNTIME|클래스 파일에 존재. 실행시에 사용가능.|

<br>
'@Override'나 '@SuppressWarnings'처럼 컴파일러가 사용하는 애너테이션은 유지 정책이 `SOURCE`이다.  
유지 정책을 `RUNTIME`으로 하면, 실행 시에 '리플렉션(reflection)'을 통해 클래스 파일에 저장된 애너테이션의 정보를 읽어서 처리할 수 있다.  
유자 정책 `CLASS`는 컴파일러가 애너테이션의 정보를 클래스 파일에 저장할 수 있게 하지만, 클래스 파일이 JVM에 로딩될 때는 애너테이션의 정보가 무시되어 실행 시에 애너테이션에 대한 정보를 얻을 수 없다. 
이것이 `CLASS`가 유지정책의 기본값임에도 불구하고 잘 사용되지 않는 이유이다.
<br>  

### 32. @Documented, @Inherited  
__`@Documented`는 애너테이션에 대한 정보가 javadoc으로 작성한 문서에 포함되도록 한다.__ 
자바에서 제공하는 기본 애너테이션 중에 '@Override'와 '@SuppressWarnings'를 제외하고는 모두 이 메타 애너테이션이 붙어 있다.  
<br>
__`@Inherited`는 애너테이션이 자손 클래스에 상속되도록 한다.__ 
'@Inherited'가 붙은 애너테이션을 조상 클래스에 붙이면, 자손 클래스도 이 애너테이션이 붙은 것과 같이 인식된다.  
<br>

### 33. @Repeatable  
보통은 하나의 대상에 한 종류의 애너테이션을 붙이는데, __`@Repeatable`이 붙은 애너테이션은 여러 번 붙일 수 있다.__  
일반적인 애너테이션과 달리 같은 이름의 애너테이션이 하나의 대상에 여러 번 적용될 수 있기 때문에, 이 애너테이션들을 하나로 묶어서 다룰 수 있는 애너테이션도 추가로 정의해야 한다.  
<br>

### 34. 애너테이션 타입 정의하기   
새로운 애너테이션을 정의하는 방법은 아래와 같다.  
`@` 기호를 붙이는 것을 제외하면 인터페이스를 정의하는 것과 동일하다.  
```java
@interface 애너테이션이름{
    타입 요소이름();  // 애너테이션의 요소를 선언한다.  
}
```
<br>  

### 35. 애너테이션의 요소  
__애너테이션 내에 선언된 메서드를 `애너테이션의 요소`라고 한다.__  
애너테이션의 요소는 반환값이 있고 매개변수는 없는 추상메서드의 형태를 가지며, 상속을 통해 구현하지 않아도 된다. 
다만, 애너테이션은 적용할 때 이 요소들의 값을 빠짐없이 지정해주어야 한다. 
애너테이션의 각 요소는 기본값을 가질 수 있으며, 기본값이 있는 요소는 애너테이션을 적용할 때 지정하지 않으면 기본값이 사용된다.  
애너테이션 요소가 오직 하나뿐이고 이름이 value인 경우, 애너테이션을 적용할 때 요소의 이름을 생략하고 값만 적어도 된다. 
요소의 타입이 배열인 경우, 괄호{}를 사용해서 여러 개의 값을 지정할 수 있다.   
<br>

### 36. 모든 애너테이션의 조상  
__모든 애너테이션의 조상은 `Annotation`이다.__   
그러나 애너테이션은 상속이 허용되지 않으므로 명시적으로 Annotation을 조상으로 지정할 수 없다.  
게다가 Annotaion은 애너테이션이 아니라 일반적인 인터페이스로 정의되어 있다. 
모든 애너테이션의 조상인 Annotation 인터페이스가 위와 같이 정의되어 있기 떄문에, 모든 애너테이션 객체에 대해 equals(), hashCode(), toString()과 같은 메서드를 호출하는 것이 가능하다.  
<br>  

### 37. 마커 애너테이션  
값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 있다.  
__요소가 하나도 정의되지 않은 애너테이션을 `마커 애너테이션`이라고 한다.__  
<br>  

### 38. 애너테이션 요소의 규칙  
애너테이션의 요소를 선언할 때 반드시 지켜야 하는 규칙은 다음과 같다.  
```markdown
- 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용된다.
- () 안에 매개변수를 선언할 수 없다.
- 예외를 선언할 수 없다.
- 요소를 타입 매개변수로 정의할 수 없다.
```
```java
@interface AnnoTest{
    int id = 100;   // OK. 상수 선언.
    String major(int i, int j);         // 에러. 매개변수를 선언할 수 없음.  
    String minor() throws Exception;    // 에러. 예외를 선언할 수 없음.
    ArrayList<T> list();                // 에러. 요소의 타입에 타입 매개변수 사용 불가.  
}
```
