CH12. 지네릭스, 열거형, 애너테이션  
=========================
### 01. 지네릭스(Generics)  
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 `컴파일 시의 타입 체크(compile-time type check)`를 해주는 기능이다. 
객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움이 줄어든다.  
저장할 객체의 타입을 지정해주면, 지정한 타입 외에 다른 타입의 객체가 저장되면 에러가 발생한다. 
그리고 저장된 객체를 꺼낼 때는 형변환할 필요가 없어서 편리하다.  
```markdown
_지네릭스의 장점_  
1. 타입 안정성을 제공한다.  
2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해진다.
```
<br>

### 02. 타입 변수  
ArrayList 클래스의 선언에서 클래스 이름 옆의 `<>` 안에 있는 E를 `타입 변수(type variable)`라고 하며, 일반적으로 'Type'의 첫 글자를 따서 T를 사용한다. 
그렇다고 타입 변수로 반드시 T를 사용해야 하는 것은 아니며, T가 아닌 다른 것을 사용해도 된다. 
주로 ArrayList<E>와 Map(K,V)처럼 첫 글자를 따서 타입 변수의 이름으로 사용한다. 

기존에는 다양한 종류의 타입을 다루는 메서드의 매개변수나 리턴 타입으로 Object 타입의 참조변수를 많이 사용했고, 그로 인해 형변환이 불가피했지만, 
이젠 Object 타입 대신 원하는 타입을 지정하기만 하면 되는 것이다.  
<br>

### 03. 타입 변수에 대입하기   
ArrayList와 같은 지네릭 클래스를 생성할 때는 다음과 같이 참조변수와 생성자에 타입 변수 E 대신에 Tv와 같은 실제 타입을 지정해주어야 한다.  
```java
// 타입 변수 E 대신에 실제 타입 Tv를 대입  
ArrayList<Tv> tvList = new ArrayList<Tv>();
```
이때, 타입 변수 E대신 지정된 타입 Tv를 `대입된 타입(parameterized type)`이라고 한다. 
타입이 대입되고 나면 ArrayList의 선언에 포함된 타입 변수 E가 아래와 같이 지정된 타입으로 바뀐다고 생각하면 된다. 
타입이 대입되어 ArrayList의 get() 메서드가 Object가 아닌 Tv를 반환하게 되므로 형변환이 필요없게 되는 것이다.   
<br>

### 04. 지네릭스 용어  
```java
class Box<T> {}
```
```markdown
Box<T>   지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.
T        타입 변수 또는 타입 매개변수. 
Box      원시 타입
```
타입 매개변수에 타입을 지정하는 것을 `제네릭 타입 호출`이라고 하고, 지정된 타입 'String'을 `매개변수화된 타입` 또는 `대입된 타입`이라고 한다.  

Box<String>과 Box<Integer>는 지네릭 클래스 Box<T>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 
이 둘이 별개의 클래스를 의미하는 것은 아니다.  
컴파일 후에 Box<String>과 Box<Integer>는 이들의 '원시 타입'인 Box로 바뀐다. 즉, 지네릭 타입이 제거된다.  
<br>

### 05. 지네릭 타입과 다형성  
지네릭 클래스의 객체를 생성할 때, 참조변수에 지정해준 지네릭 타입과 생성자에 지정해준 지네릭 타입은 일치해야 한다. 서로 상속관계에 있는 클래스이더라도 일치해야 한다.  
그러나 지네릭 타입이 아닌 클래스의 타입 간에 다형성을 적용하는 것은 가능하다. 이 경우에도 지네릭 타입은 일치해야 한다.  
```java
ArrayList<Tv> list = new ArrayList<Tv>();       // OK. 지네릭 타입 일치
ArrayList<Product> list = new ArrayList<Tv>();  // 에러. 지네릭 타입 불일치

List<Tv> list = new ArrayList<Tv>();            // OK. 다형성. ArrayList가 List를 구현  
List<Tv> list = new LinkedList<Tv>();           // OK. 다형성. LinkedList가 List를 구현  
```
<br>

### 07. Iterator<E>  
컬렉션 클래스뿐만 아니라 Iterator에도 제네릭스가 적용되어 있다.  
```java
public interface Iterator<E> {
    boolean hasNext();
    E next();
    void remove();
}
```
<br>

### 09. 제한된 지네릭 클래스  
__지네릭 타입에 `extends`를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.__  
```java
class FruitBox<T extends Fruit> {   // Fruit의 자손만 타입으로 지정가능  
    ArrayList<T> list = new ArrayList<T>();
}
```
여전히 한 종류의 타입만 담을 수 있지만, Fruit 클래스의 자손들만 담을 수 있다는 제한이 더 추가된 것이다. 
만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이때도 `extends`를 사용한다. `implements`를 사용하지 않는다는 점에 주의하자.  
<br>  

### 11. 제네릭스의 제약  
객체별로 다른 타입을 지정하는 것은 적절하다. 
지네릭스는 이처럼 인스턴스별로 다르게 동작하도록 만든 기능이다.  
__그러나 모든 객체에 대해 동일하게 동작해야하는 static 멤버에 타입 변수 T를 사용할 수 없다.__ 
T는 인스턴스 변수로 간주되기 때문이다.  
```java
class Box<T> {
    static T item;  // 에러  
    static int compare(T t1, T t2) {...}    // 에러  
}
```
<br>
__그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다.__ 
지네릭 타입의 참조변수를 선언하는 것은 가능하지만, 'new T[10]'과 같이 배열을 생성하는 것은 안된다는 뜻이다.  

```java
class Box<T> {
    T[] itemArr;    // OK. T 타입의 배열을 위한 참조변수 
    ...
    T[] tmpArr = new T[itemArr.length]; // 에러. 지네릭 배열 생성불가!
}
```
지네릭 배열을 생성할 수 없는 이유는 new 연산자 때문인데, 
이 연산자는 컴파일 시점에 타입 T가 뭔지 정확히 알아야 한다. 
그런데 위의 코드에 정의된 Box<T> 클래스를 컴파일하는 시점에서는 T가 어떤 타입이 될지 전혀 알 수 없다. instanceof 연산자도 new 연산자와 같은 이유로 T를 피연산자로 사용할 수 없다.  
<br>  

### 12. 와일드 카드  
지네릭 클래스를 생성할 때, 참조변수에 지정된 지네릭 타입과 생성자에 지정된 지네릭 타입은 일치해야 한다.  
지네릭 타입으로 `와일드 카드`사용하여 다형성을 적용할 수 있다. 
와일드 카드는 `기호 ?`를 사용하는데 다음과 같이 'extends'와 'super'로 상한과 하한을 제한할 수 있다.  
```markdown
<? extends T>   와일드 카드의 상한 제한. T와 그 자손들만 가능
<? super T>     와일드 카드의 하한 제한. T와 그 조상들만 가능
<?>             제한없음. 모든 타입이 가능. <? extends Object>와 동일  
```
와일드 카드를 이용하면 다음과 같이 하나의 참조변수로 다른 지네릭 타입이 지정된 객체를 다룰 수 있다.  
```java
// 제네릭 타입이 '? extends Product'이면, Product와 Product의 모든 자손이 OK
ArrayList<? extends Product> list = new ArrayList<Tv>();    // OK
ArrayList<? extends Product> list = new ArrayList<Audio>(); // OK  
```
와일드 카드를 메서드의 매개변수에 적용하면, 지네릭 타입이 다른 여러 객체를 매개변수로 지정할 수 있다.  
<br>

### 14. 지네릭 메서드,  
__메서드 선언부에 지네릭 타입이 선언된 메서드를 `지네릭 메서드`라 한다.__ 
지네릭 타입의 선언 위치는 반환 타입 바로 앞이다.  
```java
class FruitBax<T> {
        ...
    static <T> void sort(List<T> list, Comparator<? super T> c) {
        ...
    }
}
```
위의 코드에서 지네릭 클래스 FruitBox에 선언된 타입 매개변수 T와 지네릭 메서드 sort()에 선언된 타입 매개변수 T는 타입 문자만 같을 뿐 서로 다른 것이다. 
그리고 sort()가 static 메서드라는 점에 주목하자.  
앞서 설명한 것처럼, static 멤버에는 타입 매개변수를 사용할 수 없지만, 이처럼 메서드에 지네릭 타입을 선언하고 사용하는 것은 가능하다.  

메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 생각하면 이해하기 쉬운데, 
이 타입 매개변수는 메서드 내에서만 지역적으로 사용될 것이므로 메서드가 static이건 아니건 상관없다.  
```java

```






