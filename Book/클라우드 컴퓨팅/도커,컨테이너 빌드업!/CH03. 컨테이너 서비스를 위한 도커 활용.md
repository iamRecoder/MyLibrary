# CH03. 컨테이너를 위한 도커 활용  
## 3.1 컨테이너 서비스  
### 3.1.1 컨테이너 서비스란?  
컨테이너는 어떤 사물을 격리할 수 있는 공간을 뜻한다.  
바로 __컨테이너에 우리가 서비스하고자 하는 애플리케이션 코드와 프로세스를 격리한다는 의미__ 로 해석할 수 있다.  
도커 로고를 보면, 커다란 컨테이너선이 컨테이너를 싣고 나르는 고래에 비유되었고, 도커는 항만(부두)에서 이 컨테이너를 움직이는 노동자에 비유되어 컨테이너를 다루는 도커의 기능을 하나의 의미로 전달하고 있다.  

애플리케이션 개발환경이 도커 기반의 컨테이너 서비스 환경으로 전환된 이유는 무엇일까?  
대부분의 개발자가 개발, 테스트, 배포, 운영의 컴퓨팅 환경 차이로 인한 시행착오 및 다양한 오류 해결에 너무 많은 시간을 쏟는 공통적인 문제를 겪고 있다. 
바로 가변적 인프라 환경으로 인한 일관성 없는 환경 제공 때문이다.  

컨테이너 서비스는 기존 환경과 다르게 애플리케이션 실행에 필요한 바이너리,라이브러리 및 구성 파일 등을 패키지로 묶어 배포하는 방식으로 논리적 패키징 메커니즘을 제공한다. 
애플리케이션이 가지고 있는 운영체제, 하드웨어에 대한 의존성 문제를 해결한 것이다.  
이렇게 호스트 운영체제를 공유하고 애플리케이션에 필요한 환경을 패키징하는 것을 `운영체제 레벨 가상화`라고 부른다.  
- 하드웨어 레벨 가상화: 하이퍼바이저 등을 이용한 가상머신의 방식을 말한다.  
- 운영체제 레벨 가상화: 컨테이너 기반의 애플리케이션 서비스 방식을 말한다.  
<br>  

### 3.1.2 왜 도커 컨테이너 서비스일까?  
도커 도입이 갖는 의미를 알기 위해서는 먼저 도커를 이용한 컨테이너 애플리케이션 서비스 개발이 이루어지는 일반적인 과정을 이해할 필요가 있다.  
<br>  

#### 도커 기반 애플리케이션 개발의 라이프사이클  
__1 단계. 애플리케이션 코드 개발:__ 특정 서비스 구동을 위한 애플리케이션 코드 및 웹 화면 구성 등을 위한 코드를 개발한다.  

__2 단계. 베이스 이미지를 이용한 Dockerfile 작성:__ 개발에 필요한 인프라 구성 요소를 Dockerfile에 작성한다. 즉, 도커 허브를 통해 베이스 이미지를 다운로드하고 다양한 구동 명령어(FROM, RUN, CMD, ENV ...)와 애플리케이션 코드, 라이브러리, 여러 도구를 Dockerfile에 포함시킨다.  

__3 단계. Dockerfile build를 통한 새로운 이미지 생성:__ docker build 명령을 통해 작성한 Dockerfile을 실행한다. 각 단계별로 실행되는 로그를 화면에서 확인하며 이때 오류 발생 내용도 확인할 수 있다.  

__4-1 단계. 생성된 이미지를 이용한 컨테이너 실행:__ 도커 명령어 docker images를 통해 생성된 이미지를 확인하고 이미지를 통한 컨테이너를 구동(docker run)한다.  

__4-2 단계. 도커 컴포즈를 이용한 다중 컨테이너 실행:__ 도커 실행 옵션을 미리 작성한 docker-compose.yml을 통해 다중 컨테이너 간 실행 순서, 네트워크, 의존성 등을 통합 관리할 수 있고 마이크로서비스(MSA) 개발에 활용한다.  

__5-1 단계. 컨테이너 애플리케이션 서비스 테스트:__ 예를 들어, Nginx를 이용한 웹 애플리케이션 컨테이너 서비스였다면 연결하는 IP와 포트 번호를 이용하여 웹 브라우저를 이용한 페이지 연결을 확인할 수 있다.  

__5-2 단계. 마이크로서비스(MSA) 테스트:__ 5-1과 마찬가지로 해당 서비스에 대한 테스트를 진행한다.  

__6 단계. 로컬 및 원격 저장소에 이미지 저장:__ 로컬(도커 서버 또는 프라이빗 레지스트리) 및 원격(Docker hub)에 있는 이미지 저장소(registry)에 생성한 이미지를 저장(push)하여 다른 팀 간의 공유 및 지속적인 이미지 관리를 수행한다.  

__7 단계. 깃허브 등을 활용한 Dockerfile 관리:__ Dockerfile 코드를 깃허브 사이트에 저장 및 관리할 수 있고, 도커 허브 사이트와 연동하게 되면 자동화된 빌드(automated build) 기능을 이용한 이미지 생성도 가능하다.  

__8 단계. 동일 환경에서의 지속적인 애플리케이션 개발 수행:__ 1~7 과정을 통해 업무용 애플리케이션 이미지를 지속적으로 개발, 운영 및 관리할 수 있다.  

컨테이너 동작에 필요한 모든 내용을 사전에 코드로 작성하여 앤서블, 셰프, 베이그런핏, 퍼핏과 같은 인프라 프로비저닝 도구로 자동화하게 되면 기업이 필요할 때마다 애플리케이션 및 서버 환경을 적은 비용으로 빠르게 개발, 배포, 확장할 수 있다는 것이다. 
이러한 개념을 `IaC(Infrastructure as Code, 코드로서의 인프라스트럭처)`라고 한다.  
이 기능을 통해 개발자는 애플리케이션 개발, 테스트, 배포 시마다 모든 인프라 구성 요소를 하나하나 수동적으로 체크하거나 맞출 필요가 없고, 변경 불가능한 인프라 환경에서 언제든 동일한 상태에서의 개발이 가능해진다.  
<br> 

## 3.2 도커 명령어 활용  
### 3.2.1 도커 이미지 명령어  
도커 컨테이너는 일반적으로 도커 허브에서 제공하는 이미지를 기반으로 실행된다. 
도커 이미지는 도커의 핵심 기술이며 코드로 개발된 컨테이너 내부 환경 정보를 고스란히 복제하여 사용할 수 있다.  

도커 컨테이너로 사용할 도커 이미지는 `docker search`를 통해 조회하면 도커 허브 및 개인 사용자들이 공개한 관련 이미지를 살펴볼 수 있다. 
로컬 서버 및 데스크톱에 도커 이미지를 저장하기 위해서는 Dockerfile을 통해 새로운 이미지를 생성하거나 도커 허브로부터 이미지를 내려받는 방법이 있다.  

도커 허브 레지스트리로부터 도커 이미지를 내려받거나 레지스트리에 업로드하는 과정을 수행하기 위해 다음 명령을 사용한다.  
- docker pull: 도커 허브 레지스트리에서 로컬로 도커 이미지 내려받기
- docker push: 로컬에 있는 도커 이미지를 도커 허브 레지스트리에 업로드하기  
- docker login: 업로드를 하기 전 도커 허브 계정으로 로그인 수행하기  
- docker logout: 도커 허브에서 로그아웃하기  

도커 이미지 다운로드는 기본적으로 도커 허브 레지스트리로 자동 지정되고 특정 레지스트리를 수동으로 지정해서 받는 방법도 있다.  
<br>  

#### 도커 이미지 내려받기  
```docker [image] pull [OPTIONS] name[:TAG | @IMAGE_DIGEST}```
- 이미지명 뒤에 ':태그'를 포함하지 않으면 자동으로 최신 버전(latest)으로 지정되므로 기본 태그값이 latest라고 출력된다.  
- 도커 이미지명의 기본 형식은 `<네임스페이스>/이미지명?:<태그>`이고, 별도로 특정 레지스트리를 지정하지 않으면 자동으로 도커 허브의 라이브러리가 네임스페이스로 지정된다.  
- 외부 레지스트리 주소를 이용할 때 주의할 점은 웹 주소 URL에서 도메인 주소의 시작인 http://를 붙이지 않고 이미지 주소를 써야 한다는 점이다.  
ex) docker pull gcr.io/google-samples/hello-app:1.0         # 구글에서 제공하는 샘플 애플리케이션 이미지 지정  
<br>  

#### 도커 이미지 세부 정보 조회  
도커 오브젝트(이미지, 컨테이너 등)에 대한 세부 정보 조회를 위해 `docker image inspect`, `docker image history`, `물리적으로 호스트 운영체제에 저장된 영역(var/lib/docker/image)`을 이용한다.  

1. docker image inspect  
```docker image inspect [OPTIONS] IMAGE [IMAGE...}```  
이 명령의 출력 결과는 JSON 언어 형태로 출력되는 정보가 많기 때문에 포맷 옵션을 이용하여 원하는 정보만 출력할 수 있다.  
출력되는 세부 내용 중 주요 정보는 `image ID, 생성일, Docker 버전, CPU 아키텍처, 이미지 다이제스트 정보, 이미지 레이어 저장 정보`가 있다.   
<br>  
2. docker image history  
`docker image history [OPTIONS] IMAGE`  
이 명령을 통해 현재 이미지 구성을 위해 사용된 레이블 정보와 각 레이어의 수행 명령, 크기 등을 조회할 수 있다. 이미지를 구성하고 있는 레이어와 실행 정보에 관련된 내용이다.  
docker image history httpd 명령어와 var/lib/docker/image/overlay2/...에서 확인한 도커 이미지가 다운로드 되는 과정은 다음과 같다.  
    1. 도커 이미지 구조의 기본 운영체제 레이어들을 쌓는다.
    2. 운영체제 베이스 이미지 위에 아파치 웹 서버를 설치할 레이어를 올린다. 
    3. 아파치 웹 서비스에 필요한 리소스 정보 및 환경 정보가 포함된 레이어를 올린다. 이렇게 구성된 이미지는 불변의 읽기 전용 레이어들의 집합 구조인 유니언 파일 시스템이다.  
    4. 도커 이미지를 실행하면 여러 개의 컨테이너를 구동할 수 있다. 각각의 컨테이너에서 발생한 모든 변경 정보를 저장하기 위해 읽고-쓰기 레잉어를 두고 저장하게 된다.     
<br>  
3. 호스트 운영체제에 저장된 영역에서 확인  
```shell
# 도커 저장소에 사용되는 스토리지 드라이버를 조회한다. Overlay2를 사용하고 있다.
$ docker info | grep Storage  
Storage Driver: overlay2

# 도커의 모든 데이터 및 로그 정보는 다음 경로에 저장된다. 
# 도커를 리눅스 관리자 루트(root) 사용자에 설치하지 않은 경우, 루트 사용자로 변경해야만 도커 저장소 영역을 살펴볼 수 있다.  
$ sudo su -  
root@docker-host:~# cd /var/lib/docker  

# 이미지 레이어 데이터는 다음 경로에 저장된다.  
root@docker-host:/var/lib/docker# cd image/overlay2/layerdb/sha256/

# ls 명령어를 통해 이미지 다이제스트 값을 이름으로 한 디렉터리들이 출력된다.
root@docker-host:/var/lib/docker/image/overlay2/layerdb/sha256# ls
```
이미지 실행을 통해 만들어지는 컨테이너의 최상위 경로/영역은 `/var/lib/docker/image/overlay2/layerdb/sha256/이미지 다이제스트값`이다.  
컨테이너 내부 셸에서 생성한 파일은 /var/lib/docker/image/overlay2/layerdb/sha256/이미지 다이제스트값/diff에서 확인 가능하다.  

여러 레이어로 구성된 이미지는 몇 개의 컨테이너를 실행해도 별도의 읽고 쓰기가 가능한 컨테이너 레이어가 상위에 추가되므로 하위 이미지 레벨의 레이어에는 영향을 주지 않으면서 동작하는 것이 컨테이너 가상화의 특징 중 하나다.  
<br>  
#### 도커 이미지 태그 설정과 도커 로그인 및 로그아웃  
도커 태그는 원본 이미지에 참조 이미지 이름을 붙이는 명령이다.  
`docker tag 원본이미지[:태그] 참조이미지[:태그]`  
태그 설정은 단순히 새로운 참조명을 붙이는 작업이므로 이미지 ID는 변경되지 않는다.  

도커 허브 사이트에서 제공하는 저장소에 호스트에서 생성한 이미지 및 보유하고자 하는 이미지를 업로드하려면 docker login 명령을 통해 호스트에서의 접속이 이루어져야 한다.  
<br>  
#### 도커 이미지를 파일로 관리  
docker image save 명령은 도커 원본 이미지의 레이어 구조까지 포함한 복제를 수행하여 확장자 tar 파일로 이미지를 저장한다.  
도커 허브를 이용하지 못하는 경우 이미지 이전과 배포를 위해 로컬에 저장된 이미지를 파일로 저장하거나 불러올 수 있다.  
```shell
# 도커 이미지를 tar 파일로 저장.
docker image save [옵션] <파일명> [image명]  

# docker save로 저장한 tar 파일을 이미지로 불러옴.
docker image load [옵션]
```
<br>   

#### 도커 이미지 삭제  
하나 이상의 도커 이미지를 삭제하는 방법은 다음과 같다. 정식 명령은 `docker image rm`이고, 단축 명령으로 `docker rmi`를 제공한다.  
```shell
docker image rm [옵션] {이미지 이름[:태그] | 이미지 ID}

docker rmi [옵션] {이미지 이름[:태그] | 이미지 ID}
``` 
도커 이미지는 현재 사용 중인 컨테이너가 없으면 바로 삭제된다. 태그가 있는 이미지 원본은 태그된 이미지와 상관없이 삭제할 수 있다.  
참고로, 컨테이너가 실행 중인 이미지를 삭제한다면 현재 참조중인 컨테이너가 있기 때문에 삭제되지 않는다는 에러 메시지가 발생한다. 
이 경우, 먼저 구동 중인 컨테이너를 stop한 뒤 rm을 통해 제고한 후 이미지 삭제가 가능하다.  
이미지는 컨테이너 구동을 위해 존재한다. 로컬에 다운로드한 이미지 중 하나 이상의 컨테이너가 연결되지 않은 모든 이미지 제거를 위해 `docker image prune` 명령을 사용한다.  
