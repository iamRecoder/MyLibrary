# CH03. 컨테이너를 위한 도커 활용  
## 3.1 컨테이너 서비스  
### 3.1.1 컨테이너 서비스란?  
컨테이너는 어떤 사물을 격리할 수 있는 공간을 뜻한다.  
바로 __컨테이너에 우리가 서비스하고자 하는 애플리케이션 코드와 프로세스를 격리한다는 의미__ 로 해석할 수 있다.  
도커 로고를 보면, 커다란 컨테이너선이 컨테이너를 싣고 나르는 고래에 비유되었고, 도커는 항만(부두)에서 이 컨테이너를 움직이는 노동자에 비유되어 컨테이너를 다루는 도커의 기능을 하나의 의미로 전달하고 있다.  

애플리케이션 개발환경이 도커 기반의 컨테이너 서비스 환경으로 전환된 이유는 무엇일까?  
대부분의 개발자가 개발, 테스트, 배포, 운영의 컴퓨팅 환경 차이로 인한 시행착오 및 다양한 오류 해결에 너무 많은 시간을 쏟는 공통적인 문제를 겪고 있다. 
바로 가변적 인프라 환경으로 인한 일관성 없는 환경 제공 때문이다.  

컨테이너 서비스는 기존 환경과 다르게 애플리케이션 실행에 필요한 바이너리,라이브러리 및 구성 파일 등을 패키지로 묶어 배포하는 방식으로 논리적 패키징 메커니즘을 제공한다. 
애플리케이션이 가지고 있는 운영체제, 하드웨어에 대한 의존성 문제를 해결한 것이다.  
이렇게 호스트 운영체제를 공유하고 애플리케이션에 필요한 환경을 패키징하는 것을 `운영체제 레벨 가상화`라고 부른다.  
- 하드웨어 레벨 가상화: 하이퍼바이저 등을 이용한 가상머신의 방식을 말한다.  
- 운영체제 레벨 가상화: 컨테이너 기반의 애플리케이션 서비스 방식을 말한다.  
<br>  

### 3.1.2 왜 도커 컨테이너 서비스일까?  
도커 도입이 갖는 의미를 알기 위해서는 먼저 도커를 이용한 컨테이너 애플리케이션 서비스 개발이 이루어지는 일반적인 과정을 이해할 필요가 있다.  
<br>  

#### 도커 기반 애플리케이션 개발의 라이프사이클  
__1 단계. 애플리케이션 코드 개발:__ 특정 서비스 구동을 위한 애플리케이션 코드 및 웹 화면 구성 등을 위한 코드를 개발한다.  

__2 단계. 베이스 이미지를 이용한 Dockerfile 작성:__ 개발에 필요한 인프라 구성 요소를 Dockerfile에 작성한다. 즉, 도커 허브를 통해 베이스 이미지를 다운로드하고 다양한 구동 명령어(FROM, RUN, CMD, ENV ...)와 애플리케이션 코드, 라이브러리, 여러 도구를 Dockerfile에 포함시킨다.  

__3 단계. Dockerfile build를 통한 새로운 이미지 생성:__ docker build 명령을 통해 작성한 Dockerfile을 실행한다. 각 단계별로 실행되는 로그를 화면에서 확인하며 이때 오류 발생 내용도 확인할 수 있다.  

__4-1 단계. 생성된 이미지를 이용한 컨테이너 실행:__ 도커 명령어 docker images를 통해 생성된 이미지를 확인하고 이미지를 통한 컨테이너를 구동(docker run)한다.  

__4-2 단계. 도커 컴포즈를 이용한 다중 컨테이너 실행:__ 도커 실행 옵션을 미리 작성한 docker-compose.yml을 통해 다중 컨테이너 간 실행 순서, 네트워크, 의존성 등을 통합 관리할 수 있고 마이크로서비스(MSA) 개발에 활용한다.  

__5-1 단계. 컨테이너 애플리케이션 서비스 테스트:__ 예를 들어, Nginx를 이용한 웹 애플리케이션 컨테이너 서비스였다면 연결하는 IP와 포트 번호를 이용하여 웹 브라우저를 이용한 페이지 연결을 확인할 수 있다.  

__5-2 단계. 마이크로서비스(MSA) 테스트:__ 5-1과 마찬가지로 해당 서비스에 대한 테스트를 진행한다.  

__6 단계. 로컬 및 원격 저장소에 이미지 저장:__ 로컬(도커 서버 또는 프라이빗 레지스트리) 및 원격(Docker hub)에 있는 이미지 저장소(registry)에 생성한 이미지를 저장(push)하여 다른 팀 간의 공유 및 지속적인 이미지 관리를 수행한다.  

__7 단계. 깃허브 등을 활용한 Dockerfile 관리:__ Dockerfile 코드를 깃허브 사이트에 저장 및 관리할 수 있고, 도커 허브 사이트와 연동하게 되면 자동화된 빌드(automated build) 기능을 이용한 이미지 생성도 가능하다.  

__8 단계. 동일 환경에서의 지속적인 애플리케이션 개발 수행:__ 1~7 과정을 통해 업무용 애플리케이션 이미지를 지속적으로 개발, 운영 및 관리할 수 있다.  

컨테이너 동작에 필요한 모든 내용을 사전에 코드로 작성하여 앤서블, 셰프, 베이그런핏, 퍼핏과 같은 인프라 프로비저닝 도구로 자동화하게 되면 기업이 필요할 때마다 애플리케이션 및 서버 환경을 적은 비용으로 빠르게 개발, 배포, 확장할 수 있다는 것이다. 
이러한 개념을 `IaC(Infrastructure as Code, 코드로서의 인프라스트럭처)`라고 한다.  
이 기능을 통해 개발자는 애플리케이션 개발, 테스트, 배포 시마다 모든 인프라 구성 요소를 하나하나 수동적으로 체크하거나 맞출 필요가 없고, 변경 불가능한 인프라 환경에서 언제든 동일한 상태에서의 개발이 가능해진다.  
<br> 

## 3.2 도커 명령어 활용  
### 3.2.1 도커 이미지 명령어  
도커 컨테이너는 일반적으로 도커 허브에서 제공하는 이미지를 기반으로 실행된다. 
도커 이미지는 도커의 핵심 기술이며 코드로 개발된 컨테이너 내부 환경 정보를 고스란히 복제하여 사용할 수 있다.  

도커 컨테이너로 사용할 도커 이미지는 `docker search`를 통해 조회하면 도커 허브 및 개인 사용자들이 공개한 관련 이미지를 살펴볼 수 있다. 
로컬 서버 및 데스크톱에 도커 이미지를 저장하기 위해서는 Dockerfile을 통해 새로운 이미지를 생성하거나 도커 허브로부터 이미지를 내려받는 방법이 있다.  

도커 허브 레지스트리로부터 도커 이미지를 내려받거나 레지스트리에 업로드하는 과정을 수행하기 위해 다음 명령을 사용한다.  
- docker pull: 도커 허브 레지스트리에서 로컬로 도커 이미지 내려받기
- docker push: 로컬에 있는 도커 이미지를 도커 허브 레지스트리에 업로드하기  
- docker login: 업로드를 하기 전 도커 허브 계정으로 로그인 수행하기  
- docker logout: 도커 허브에서 로그아웃하기  

도커 이미지 다운로드는 기본적으로 도커 허브 레지스트리로 자동 지정되고 특정 레지스트리를 수동으로 지정해서 받는 방법도 있다.  
<br>  

#### 도커 이미지 내려받기  
```docker [image] pull [OPTIONS] name[:TAG | @IMAGE_DIGEST}```
- 이미지명 뒤에 ':태그'를 포함하지 않으면 자동으로 최신 버전(latest)으로 지정되므로 기본 태그값이 latest라고 출력된다.  
- 도커 이미지명의 기본 형식은 `<네임스페이스>/이미지명?:<태그>`이고, 별도로 특정 레지스트리를 지정하지 않으면 자동으로 도커 허브의 라이브러리가 네임스페이스로 지정된다.  
- 외부 레지스트리 주소를 이용할 때 주의할 점은 웹 주소 URL에서 도메인 주소의 시작인 http://를 붙이지 않고 이미지 주소를 써야 한다는 점이다.  
ex) docker pull gcr.io/google-samples/hello-app:1.0         # 구글에서 제공하는 샘플 애플리케이션 이미지 지정  
<br>  

#### 도커 이미지 세부 정보 조회  
도커 오브젝트(이미지, 컨테이너 등)에 대한 세부 정보 조회를 위해 `docker image inspect`, `docker image history`, `물리적으로 호스트 운영체제에 저장된 영역(var/lib/docker/image)`을 이용한다.  

1. docker image inspect  
```docker image inspect [OPTIONS] IMAGE [IMAGE...}```  
이 명령의 출력 결과는 JSON 언어 형태로 출력되는 정보가 많기 때문에 포맷 옵션을 이용하여 원하는 정보만 출력할 수 있다.  
출력되는 세부 내용 중 주요 정보는 `image ID, 생성일, Docker 버전, CPU 아키텍처, 이미지 다이제스트 정보, 이미지 레이어 저장 정보`가 있다.   
<br>  
2. docker image history  
`docker image history [OPTIONS] IMAGE`  
이 명령을 통해 현재 이미지 구성을 위해 사용된 레이블 정보와 각 레이어의 수행 명령, 크기 등을 조회할 수 있다. 이미지를 구성하고 있는 레이어와 실행 정보에 관련된 내용이다.  
docker image history httpd 명령어와 var/lib/docker/image/overlay2/...에서 확인한 도커 이미지가 다운로드 되는 과정은 다음과 같다.  
    1. 도커 이미지 구조의 기본 운영체제 레이어들을 쌓는다.
    2. 운영체제 베이스 이미지 위에 아파치 웹 서버를 설치할 레이어를 올린다. 
    3. 아파치 웹 서비스에 필요한 리소스 정보 및 환경 정보가 포함된 레이어를 올린다. 이렇게 구성된 이미지는 불변의 읽기 전용 레이어들의 집합 구조인 유니언 파일 시스템이다.  
    4. 도커 이미지를 실행하면 여러 개의 컨테이너를 구동할 수 있다. 각각의 컨테이너에서 발생한 모든 변경 정보를 저장하기 위해 읽고-쓰기 레잉어를 두고 저장하게 된다.     
<br>  
3. 호스트 운영체제에 저장된 영역에서 확인  
```shell
# 도커 저장소에 사용되는 스토리지 드라이버를 조회한다. Overlay2를 사용하고 있다.
$ docker info | grep Storage  
Storage Driver: overlay2

# 도커의 모든 데이터 및 로그 정보는 다음 경로에 저장된다. 
# 도커를 리눅스 관리자 루트(root) 사용자에 설치하지 않은 경우, 루트 사용자로 변경해야만 도커 저장소 영역을 살펴볼 수 있다.  
$ sudo su -  
root@docker-host:~# cd /var/lib/docker  

# 이미지 레이어 데이터는 다음 경로에 저장된다.  
root@docker-host:/var/lib/docker# cd image/overlay2/layerdb/sha256/

# ls 명령어를 통해 이미지 다이제스트 값을 이름으로 한 디렉터리들이 출력된다.
root@docker-host:/var/lib/docker/image/overlay2/layerdb/sha256# ls
```
이미지 실행을 통해 만들어지는 컨테이너의 최상위 경로/영역은 `/var/lib/docker/image/overlay2/layerdb/sha256/이미지 다이제스트값`이다.  
컨테이너 내부 셸에서 생성한 파일은 /var/lib/docker/image/overlay2/layerdb/sha256/이미지 다이제스트값/diff에서 확인 가능하다.  

여러 레이어로 구성된 이미지는 몇 개의 컨테이너를 실행해도 별도의 읽고 쓰기가 가능한 컨테이너 레이어가 상위에 추가되므로 하위 이미지 레벨의 레이어에는 영향을 주지 않으면서 동작하는 것이 컨테이너 가상화의 특징 중 하나다.  
<br>  
#### 도커 이미지 태그 설정과 도커 로그인 및 로그아웃  
도커 태그는 원본 이미지에 참조 이미지 이름을 붙이는 명령이다.  
`docker tag 원본이미지[:태그] 참조이미지[:태그]`  
태그 설정은 단순히 새로운 참조명을 붙이는 작업이므로 이미지 ID는 변경되지 않는다.  

도커 허브 사이트에서 제공하는 저장소에 호스트에서 생성한 이미지 및 보유하고자 하는 이미지를 업로드하려면 docker login 명령을 통해 호스트에서의 접속이 이루어져야 한다.  
<br>  
#### 도커 이미지를 파일로 관리  
docker image save 명령은 도커 원본 이미지의 레이어 구조까지 포함한 복제를 수행하여 확장자 tar 파일로 이미지를 저장한다.  
도커 허브를 이용하지 못하는 경우 이미지 이전과 배포를 위해 로컬에 저장된 이미지를 파일로 저장하거나 불러올 수 있다.  
```shell
# 도커 이미지를 tar 파일로 저장.
docker image save [옵션] <파일명> [image명]  

# docker save로 저장한 tar 파일을 이미지로 불러옴.
docker image load [옵션]
```
<br>   

#### 도커 이미지 삭제  
하나 이상의 도커 이미지를 삭제하는 방법은 다음과 같다. 정식 명령은 `docker image rm`이고, 단축 명령으로 `docker rmi`를 제공한다.  
```shell
docker image rm [옵션] {이미지 이름[:태그] | 이미지 ID}

docker rmi [옵션] {이미지 이름[:태그] | 이미지 ID}
``` 
도커 이미지는 현재 사용 중인 컨테이너가 없으면 바로 삭제된다. 태그가 있는 이미지 원본은 태그된 이미지와 상관없이 삭제할 수 있다.  
참고로, 컨테이너가 실행 중인 이미지를 삭제한다면 현재 참조중인 컨테이너가 있기 때문에 삭제되지 않는다는 에러 메시지가 발생한다. 
이 경우, 먼저 구동 중인 컨테이너를 stop한 뒤 rm을 통해 제고한 후 이미지 삭제가 가능하다.  
이미지는 컨테이너 구동을 위해 존재한다. 로컬에 다운로드한 이미지 중 하나 이상의 컨테이너가 연결되지 않은 모든 이미지 제거를 위해 `docker image prune` 명령을 사용한다.  
<br>  

### 3.2.2 도커 컨테이너 명령어  
이미지는 읽기 전용의 불변 값으로 만들어진다. 
이러한 이미지를 바탕으로 도커 엔진은 컨테이너를 생성할 수 있다.  
이때, 이미지와 함께 읽고 쓰기가 가능한 레이어를 추가해서 만들어지는 것이 `컨테이너`이다.  
이미지와 마찬가지로 컨테이너 명령도 dockerd 데몬이 제공하는 docker CLI API를 통해 제공된다.  
<br>  
#### 컨테이너는 프로세스다  
도커 컨테이너는 앞서 배운 도커 이미지를 기반으로 만들어지는 `스냅숏`이다. 
이 스냅숏은 읽기 전용의 `도커 이미지 레이어`를 복제한 것이고, 그 위에 읽고 쓰기가 가능한 `컨테이너 레이어`를 결합하면 컨테이너가 된다.  

__컨테이너는 격리된 공간에서 프로세스가 동작하는 기술이다.__ 
컨테이너는 바로 프로세스 격리 기술(namespaces, cgroups, chroot)의 표준으로 정의된 OCI(Open Container Initiative)로 컨테이너 포맷과 런타임에 대한 개방형 업계 표준을 만들기 위한 목적으로 리눅스 파운데이션의 지원을 받아 구성된 오픈 프로젝트다.  

__명령어 `docker run ~`을 사용하면 컨테이너가 동작하게 되고, 가상의 격리 환경에 독립된 프로세스가 동작한다.__ 
마치 서버 호스트 운영체제가 독립적으로 동작하는 것과 유사하다.  

독립된 호스트 운영체제는 init 프로세스와 같은 최상위 부모 프로세스가 필요하다. 
__도커는 docker run ~ 수행 시 PID 네임스페이스 커널 기능을 통해 시스템의 1번 프로세스의 PID를 공유하고 그 하위로 프로세스를 격리한다.__ 
이렇게 격리된 프로세스를 루트로부터 변경하는 `chroot` 커널 기능을 통해 독립된 1번 PID를 갖게 되고, 컨테이너 동작 시 필요한 자원에 대한 할당은 `cgroups` 커널 기능을 통해 이루어진다.  
<br>  

#### 컨테이너 실행  
```docker run = [pull] + create + start + [command]```  

docker run은 상당히 많은 옵션을 가지고 있다. 그만큼 컨테이너 내부의 애플리케이션 동작을 세세하게 제어할 수 있다는 의미이기도 하다.  

|                    옵션                     |                           설명                           |
|:-----------------------------------------:|:------------------------------------------------------:|
|             -i, --interactive             |                       대화식 모드 열기                        |
|                    -t                     |                     TTY(단말 디바이스 할당                     |
|             -d, --detach=true             |              백그라운드에서 컨테이너 실행 후 컨테이너 ID 등록              |  
|                  --name                   |    실행되는 컨테이너에 이름 부여(미지정 시 자동으로 부여됨: 딕셔너리 워드 랜덤 선택)     |
|                   --rm                    |                 컨테이너 종료 시 자동으로 컨테이너 제거                 |
|                 --restart                 |                컨테이너 종료 시 적용할 재시작 정책 지정                 |
|                   --env                   | 컨테이너의 환경 변수 지정(--env-file은 여러 환경 변수를 파일로 생성하여 지정하는 방법) |
|       -v, <br>--volume=호스트경로:컨테이너경로       |       호스트 경로와 컨테이너 경로의 공유 볼륨 설정 (Bind mount라고 함)       |
|                    -h                     |컨테이너의 호스트명 지정(미지정 시 컨테이너 ID가 호스트명으로 등록)|
| -p [Host 포트]:[Container 포트],<br>--publish |호스트 포트와 컨테이너 포트 연결|
|   -P,<br>--publish-all=[true or false]    |컨테이너 내부의 노출된(expose) 포트를 호스트 임의의 포트에 게시|
|      --link=[container:container_id]      |동일 호스트의 다른 컨테이ㅓㄴ와 연결 설정으로 IP가 아닌 컨테이너의 이름을 통해 통신|

<br>

#### 컨테이너 모니터링 도구 cAdivisor 컨테이너 실행  
- 서비스 운영을 하면서 필요한 시스템 Metric(CPU/메모리 사용률, 네트워크 트래픽 등)을 모니터링하면서 특이사항이 있을 때 대응하기 위해 모니터링 수행
- 그러나 컨테이너라는 환경하에서는 기존 모니터링 도구로는 container 모니터링 진행이 어려움
- 이러한 문제점을 해결하고 컨테이너를 모니터링하기 위한 도구로 구글에서 제공하는 cAdvisor(Container Advisor)를 많이 사용한다.  

```shell
# cAdvisor 실행 명령어
docker run 
>  --volume=/:/rootfs:ro \
>  --volume=/var/run:/var/run:rw \
>  --volume=/sys:/sys:ro \
>  --volume=/var/lib/docker/:/var/lib/docker:ro \
>  --publish=9559:8080  \
>  --detach=true  \
>  --name=cadvisor  \
>  google/cadvisor:latest
```  

<br>

### 3.2.3 도커 볼륨 활용
애플리케이션에서 발생하는 데이터에 접근하고 이것을 공유하기 위해서 도커 볼륨 기능을 사용할 수 있다. 
또한 제공하는 서비스의 데이터와 로직은 반드시 분리되어야 한다. 
애플리케이션에서 발생하는 여러 가지 상황이 데이터에 영향을 주지 않고 언제든 다른 컨테이너로 이전할 수 있다면 운영자는 데이터를 안전하게 관리하고 운영할 수 있다.  

도커 볼륨은 컨테이너에서 생성, 재사용할 수 있고 호스트 운영체제에서 직접 접근이 가능하다. 
또한 보존되어야 하는 데이터를 유지하기 위한 메커니즘을 제공한다. 
일반적으로 컨테이너 내부의 데이터는 컨테이너의 라이프사이클과 연관되어 컨테이너 종료 시 삭제된다. 
이를 영속적으로 유지하기 위한 방법으로 도커 볼륨을 사용하면 컨테이너가 삭제되어도 볼륨은 독립적으로 운영되기 때문에 함께 삭제되지 않는 특징이 있다.  
<br>

#### 도커 볼륨 타입  
1. volume
   - 도커에서 권장하는 방법. `docker volume create 볼륨 이름`을 통해 볼륨 생성한다.
   - 볼륨 드라이버를 통해 원격 호스트 및 클라우드 환경에 볼륨 내용을 저장하고 암호화할 수 있다.
   - 새 볼륨으로 지정될 영역에 데이터를 미리 채우고 컨테이너에 연결하면 컨테이너 내에서 바로 데이터 가용이 가능하다.
2. bind mount
   - 도커 볼륨 기법에 비해 사용이 제한적이다.
   - 호스트 파일 시스템 절대경로: 컨테이너 내부 경로를 직접 마운트하여 사용한다.
   - 컨테이너 실행 시 지정하여 사용하고, 컨테이너 제거 시 바운드 마운트는 해제되지만 호스트 디렉터리는 유지된다.  
3. tmpfs mount
   - 위 방법들은 컨테이너가 중지된 후에도 데이터를 유지할 수 있지만 tmpfs 마운트 방법은 임시적이며 호스트 메모리에서만 지속되므로 컨테이너가 중지되면 tmpfs 마운트가 제거되고 내부에 기록된 파일은 유지되지 않는다.  
   - 컨테이너 실행 시 지정하여 사용하고, 컨테이너 제거 시 자동 해제된다.  
<br>  

#### 도커 볼륨 활용  
- 데이터베이스의 데이터 지속성 유지
- 웹 서비스 로그 정보 보호 및 분석
- 컨테이너 간 데이터 공유
- 수정 적용 (컨테이너 실행 시 볼륨을 지정했다면 docker cp 명령을 쓰지 않고도 해당 볼륨 경로에 변경된 웹 소스만 넣어주면 바로 적용이 가능하다)
- 컨테이너 내부에서 사용할 수 있는 볼륨 공간 제한

<br>

### 3.2.4 도커 컨테이너의 자원 사용에 대한 런타임 제약  
#### 서버 자원 모니터링  
서버 자원 모니터링은 CPU, 메모리, 디스크 I/O, 네트워크 트래픽 등을 기본적으로 살펴보면서 성능에 문제점이 발생할 것 같은 징후를 찾아 예방하는 것이 목적이다.  
이러한 자원을 모니터링하기 위해 다음과 같은 도구를 종종 사용한다.  

< 서버 자원 모니터링 도구 >

|도구|설명|
|:---:|:---:|
|top|리눅스 전체의 자원 소비량 및 개별 액티브 프로세스의 자원 사용량|
|htop|top보다 향상된 자원 사용량 제공(별도 설치 요구)|
|sar|(system activity report) 다양한 옵션을 통해 시스템 전반의 사용량에 대한 세부적인 모니터링 제공, 주로 셸 스크립트에 포함하여 활용(별도 설치 요구)|
|iostat, df| 디스크 성능 지표인 IOPS와 MBPS 측정 가능(sar과 함께 설치)|
|vmstat, free| 메모리 성능 측정이 가능|
|dstat|서버 전반의 자원 사용량에 대한 모니터링 제공, 개별 옵션으로 제어 가능(별도 설치 요구)|
|iptraf-ng| 서버로 유입되는 네트워크 인터페이스별 패킷양, 프로토콜 등을 통해 네트워크 트래픽 모니터링(별도 설치 요구)|

<br>

### 3.2.5 도커 네트워크  
#### 도커 네트워크 개요  




